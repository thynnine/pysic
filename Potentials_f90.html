

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>potentials (Potentials.f90) &mdash; Pysic 0.6 documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Pysic 0.6 documentation" href="index.html" />
    <link rel="up" title="Pysic Fortran module" href="pysic_fortran.html" />
    <link rel="next" title="geometry (Geometry.f90)" href="Geometry_f90.html" />
    <link rel="prev" title="pysic_core (Core.f90)" href="Core_f90.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="Geometry_f90.html" title="geometry (Geometry.f90)"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="Core_f90.html" title="pysic_core (Core.f90)"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Pysic 0.6 documentation</a> &raquo;</li>
          <li><a href="pysic_fortran.html" accesskey="U">Pysic Fortran module</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">potentials (Potentials.f90)</a><ul>
<li><a class="reference internal" href="#modules-used-by-potentials">Modules used by potentials</a></li>
<li><a class="reference internal" href="#list-of-global-variables-in-potentials">List of global variables in potentials</a></li>
<li><a class="reference internal" href="#list-of-custom-types-in-potentials">List of custom types in potentials</a></li>
<li><a class="reference internal" href="#list-of-subroutines-in-potentials">List of subroutines in potentials</a></li>
<li><a class="reference internal" href="#full-documentation-of-global-variables-in-potentials">Full documentation of global variables in potentials</a></li>
<li><a class="reference internal" href="#full-documentation-of-custom-types-in-potentials">Full documentation of custom types in potentials</a></li>
<li><a class="reference internal" href="#full-documentation-of-subroutines-in-potentials">Full documentation of subroutines in potentials</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="Core_f90.html"
                        title="previous chapter">pysic_core (Core.f90)</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="Geometry_f90.html"
                        title="next chapter">geometry (Geometry.f90)</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/Potentials_f90.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="potentials-potentials-f90">
<span id="potentials"></span><h1>potentials (Potentials.f90)<a class="headerlink" href="#potentials-potentials-f90" title="Permalink to this headline">¶</a></h1>
<p>Potentials contains the low-level routines for handling interactions.
The module defines custom types for both describing the types of
potentials and bond order factors (<a class="reference internal" href="#potential_descriptor" title="potential_descriptor"><tt class="xref py py-data docutils literal"><span class="pre">potential_descriptor</span></tt></a>, <a class="reference internal" href="#bond_order_descriptor" title="bond_order_descriptor"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_descriptor</span></tt></a>)
as well as for storing the parameters of actual interactions in use
for the Fortran calculations (<a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a>, <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a>).
Tools for creating the custom datatypes (<a class="reference internal" href="#create_potential" title="create_potential"><tt class="xref py py-func docutils literal"><span class="pre">create_potential()</span></tt></a>, <a class="reference internal" href="#create_bond_order_factor" title="create_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">create_bond_order_factor()</span></tt></a>)
are provided.</p>
<p>The types of potentials and bond order factors are defined using the types
<a class="reference internal" href="#potential_descriptor" title="potential_descriptor"><tt class="xref py py-data docutils literal"><span class="pre">potential_descriptor</span></tt></a> and <a class="reference internal" href="#bond_order_descriptor" title="bond_order_descriptor"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_descriptor</span></tt></a>.
These should be created at start-up and remain untouched during simulation.
They are used by the Fortran core for checking the types of parameters a potential
needs, for instance, but they are also accessible from the Python interface.
Especially, upon creation of <tt class="xref py py-class docutils literal"><span class="pre">Potential</span></tt> and <tt class="xref py py-class docutils literal"><span class="pre">BondOrderParameters</span></tt>
instances, one needs to specify the type as a keyword. This keyword is then compared to the list of
characterizers in the core to determine the type of the interaction.</p>
<p>The basic routines for calculating the actual forces and energies are also defined in
this module (<a class="reference internal" href="#evaluate_energy" title="evaluate_energy"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_energy()</span></tt></a>, <a class="reference internal" href="#evaluate_forces" title="evaluate_forces"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_forces()</span></tt></a>, <a class="reference internal" href="#evaluate_bond_order_factor" title="evaluate_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_bond_order_factor()</span></tt></a>,
<a class="reference internal" href="#evaluate_bond_order_gradient" title="evaluate_bond_order_gradient"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_bond_order_gradient()</span></tt></a>). However, these routines do not calculate the total potential
energy of the system, <span class="math">\(V\)</span>, or the total forces acting on the particles,
<span class="math">\(\mathbf{F} = -\nabla_\alpha V\)</span>. Instead, the routines evaluate the contributions from individual
atoms, atom pairs, atom triplets, etc. For instance, let the total energy of the system be</p>
<div class="math">
\[V = \sum_p \left( \sum_i v^p_i + \sum_{(i,j)} v^p_{ij} + \sum_{(i,j,k)} v^p_{ijk} \right),\]</div>
<p>where <span class="math">\(p\)</span> sums over the different potentials acting on the system and <span class="math">\(i\)</span>, <span class="math">\((i,j)\)</span> and
<span class="math">\((i,j,k)\)</span> sum over all atoms, pairs and triplet, respectively. Then the energy terms <span class="math">\(v\)</span>
are obtained from <a class="reference internal" href="#evaluate_energy" title="evaluate_energy"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_energy()</span></tt></a>. In pseudo-code,</p>
<div class="math">
\[v^p_{S} = \mathtt{evaluate\_energy}(S,p),\]</div>
<p>where <span class="math">\(S\)</span> is a set of atoms. The summation over potentials and atoms is done in <a class="reference internal" href="Core_f90.html#pysic-core"><em>pysic_core (Core.f90)</em></a>
in <a class="reference internal" href="PyInterface_f90.html#calculate_energy" title="calculate_energy"><tt class="xref py py-func docutils literal"><span class="pre">calculate_energy()</span></tt></a>. Similarly for forces, the summation is carried out in <a class="reference internal" href="PyInterface_f90.html#calculate_forces" title="calculate_forces"><tt class="xref py py-func docutils literal"><span class="pre">calculate_forces()</span></tt></a>.</p>
<p>The reason for separating the calculation of individual interaction terms to <a class="reference internal" href="#potentials"><em>potentials (Potentials.f90)</em></a>
and the overall summation to <a class="reference internal" href="Core_f90.html#pysic-core"><em>pysic_core (Core.f90)</em></a> is that only the core knows the current structure and
interactions of the system.
It is the task of this module to tell the core how all the potentials behave given
any local structure, but the overall system information is kept in the core. So during energy
evaluation, <a class="reference internal" href="Core_f90.html#pysic-core"><em>pysic_core (Core.f90)</em></a> finds all local structures that possibly contribute with an interaction
and asks <a class="reference internal" href="#potentials"><em>potentials (Potentials.f90)</em></a> to calculate this contribution.</p>
<p>Bond order factors are potential modifiers, not direct interactions themselves.
In general, the factors are scalar functions defined per atom, for instance,</p>
<div class="math">
\[b^p_i = s^p_i\left( \sum_{(i,j)} c^p_{ij} + \sum_{(i,j,k)} c^p_{ijk} \right)\]</div>
<p>for a three-body factor, where <span class="math">\(c^p\)</span> are local contributions
(usually representing chemical bonds) and <span class="math">\(s^p_i\)</span> is a per atom scaling function.
The bond factors multiply the potentials <span class="math">\(p\)</span>
leading to the total energy</p>
<div class="math">
\[V = \sum_p \left( \sum_i b^p_i v^p_i + \sum_{(i,j)} \frac{1}{2}(b^p_i+b^p_j) v^p_{ij} + \sum_{(i,j,k)} \frac{1}{3}(b^p_i+b^p_j+b^p_k) v^p_{ijk} \right).\]</div>
<p>The corresponding total force on atom <span class="math">\(\alpha\)</span> is then</p>
<div class="math">
\[\mathbf{F}_{\alpha} = - \nabla_\alpha V = - \sum_p \left( \sum_i ((\nabla_\alpha b^p_i) v^p_i + b^p_i (\nabla_\alpha v^p_i) ) + \ldots \right).\]</div>
<p>The contributions <span class="math">\(\mathbf{f}^p_\alpha = -\nabla_\alpha v^p\)</span>, <span class="math">\(c^p\)</span>,
and <span class="math">\(\nabla_\alpha c^p\)</span> are
calculated in <a class="reference internal" href="#evaluate_forces" title="evaluate_forces"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_forces()</span></tt></a>, <a class="reference internal" href="#evaluate_bond_order_factor" title="evaluate_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_bond_order_factor()</span></tt></a>,
and <a class="reference internal" href="#evaluate_bond_order_gradient" title="evaluate_bond_order_gradient"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_bond_order_gradient()</span></tt></a>.
Application of the scaling functions <span class="math">\(s_i\)</span> and <span class="math">\(s_i'\)</span> on the sums
<span class="math">\(\sum_{(i,j)} c^p_{ij} + \sum_{(i,j,k)} c^p_{ijk}\)</span> is done in the routines
<a class="reference internal" href="#post_process_bond_order_factor" title="post_process_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">post_process_bond_order_factor()</span></tt></a> and <a class="reference internal" href="#post_process_bond_order_gradient" title="post_process_bond_order_gradient"><tt class="xref py py-func docutils literal"><span class="pre">post_process_bond_order_gradient()</span></tt></a> to
produce the actual bond order factors <span class="math">\(b^p_i\)</span> and gradients <span class="math">\(\nabla_\alpha b^p_i\)</span>.
These sums, similarly to the energy and force summations, are evaluated with
<a class="reference internal" href="Core_f90.html#core_calculate_bond_order_factors" title="core_calculate_bond_order_factors"><tt class="xref py py-func docutils literal"><span class="pre">core_calculate_bond_order_factors()</span></tt></a> in <a class="reference internal" href="Core_f90.html#pysic-core"><em>pysic_core (Core.f90)</em></a>.</p>
<p>Note when adding potentials or bond order factors in the source code:</p>
<p>The parameters defined in Potentials.f90 are used for determining the maximum sizes of arrays,
numbers of potentials and bond factors, and the internally used indices
for them. When adding new potentials of bond factors, make sure to update
the relevant numbers. Especially the number of potentials (<a class="reference internal" href="#n_potential_types" title="n_potential_types"><tt class="xref py py-data docutils literal"><span class="pre">n_potential_types</span></tt></a>)
or number of bond order factors (<a class="reference internal" href="#n_bond_order_types" title="n_bond_order_types"><tt class="xref py py-data docutils literal"><span class="pre">n_bond_order_types</span></tt></a>) must be increased
when more types are defined.</p>
<p>Also note that in <a class="reference internal" href="PyInterface_f90.html#pysic-interface"><em>pysic_interface (PyInterface.f90)</em></a>, some of these parameters are used for
determining array sizes. However, the actual parameters are not used
because f2py does not read the values from here. Therefore if you change
a parameter here, search for its name in <a class="reference internal" href="PyInterface_f90.html#pysic-interface"><em>pysic_interface (PyInterface.f90)</em></a> to see if the
name appears in a comment. That is an indicator that a numeric value
must be updated accordingly.</p>
<div class="section" id="modules-used-by-potentials">
<h2>Modules used by potentials<a class="headerlink" href="#modules-used-by-potentials" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference internal" href="Geometry_f90.html#geometry"><em>geometry (Geometry.f90)</em></a></li>
<li><a class="reference internal" href="MPI_f90.html#mpi"><em>mpi (MPI.f90)</em></a></li>
<li><a class="reference internal" href="Quaternions_f90.html#quaternions"><em>quaternions (Quaternions.f90)</em></a></li>
<li><a class="reference internal" href="Utility_f90.html#utility"><em>utility (Utility.f90)</em></a></li>
</ul>
</div>
<div class="section" id="list-of-global-variables-in-potentials">
<h2>List of global variables in potentials<a class="headerlink" href="#list-of-global-variables-in-potentials" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference internal" href="#bond_descriptors_created" title="bond_descriptors_created"><tt class="xref py py-data docutils literal"><span class="pre">bond_descriptors_created</span></tt></a></li>
<li><a class="reference internal" href="#bond_order_descriptors" title="bond_order_descriptors"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_descriptors</span></tt></a></li>
<li><a class="reference internal" href="#c_scale_index" title="c_scale_index"><tt class="xref py py-data docutils literal"><span class="pre">c_scale_index</span></tt></a></li>
<li><a class="reference internal" href="#coordination_index" title="coordination_index"><tt class="xref py py-data docutils literal"><span class="pre">coordination_index</span></tt></a></li>
<li><a class="reference internal" href="#descriptors_created" title="descriptors_created"><tt class="xref py py-data docutils literal"><span class="pre">descriptors_created</span></tt></a></li>
<li><a class="reference internal" href="#ewald_arrays_allocated" title="ewald_arrays_allocated"><tt class="xref py py-data docutils literal"><span class="pre">ewald_arrays_allocated</span></tt></a></li>
<li><a class="reference internal" href="#ewald_forces" title="ewald_forces"><tt class="xref py py-data docutils literal"><span class="pre">ewald_forces</span></tt></a></li>
<li><a class="reference internal" href="#ewald_sum_forces" title="ewald_sum_forces"><tt class="xref py py-data docutils literal"><span class="pre">ewald_sum_forces</span></tt></a></li>
<li><a class="reference internal" href="#ewald_tmp_enegs" title="ewald_tmp_enegs"><tt class="xref py py-data docutils literal"><span class="pre">ewald_tmp_enegs</span></tt></a></li>
<li><a class="reference internal" href="#mono_const_index" title="mono_const_index"><tt class="xref py py-data docutils literal"><span class="pre">mono_const_index</span></tt></a></li>
<li><a class="reference internal" href="#mono_none_index" title="mono_none_index"><tt class="xref py py-data docutils literal"><span class="pre">mono_none_index</span></tt></a></li>
<li><a class="reference internal" href="#mono_qself_index" title="mono_qself_index"><tt class="xref py py-data docutils literal"><span class="pre">mono_qself_index</span></tt></a></li>
<li><a class="reference internal" href="#n_bond_order_types" title="n_bond_order_types"><tt class="xref py py-data docutils literal"><span class="pre">n_bond_order_types</span></tt></a></li>
<li><a class="reference internal" href="#n_max_params" title="n_max_params"><tt class="xref py py-data docutils literal"><span class="pre">n_max_params</span></tt></a></li>
<li><a class="reference internal" href="#n_potential_types" title="n_potential_types"><tt class="xref py py-data docutils literal"><span class="pre">n_potential_types</span></tt></a></li>
<li><a class="reference internal" href="#no_name" title="no_name"><tt class="xref py py-data docutils literal"><span class="pre">no_name</span></tt></a></li>
<li><a class="reference internal" href="#pair_buck_index" title="pair_buck_index"><tt class="xref py py-data docutils literal"><span class="pre">pair_buck_index</span></tt></a></li>
<li><a class="reference internal" href="#pair_exp_index" title="pair_exp_index"><tt class="xref py py-data docutils literal"><span class="pre">pair_exp_index</span></tt></a></li>
<li><a class="reference internal" href="#pair_lj_index" title="pair_lj_index"><tt class="xref py py-data docutils literal"><span class="pre">pair_lj_index</span></tt></a></li>
<li><a class="reference internal" href="#pair_power_index" title="pair_power_index"><tt class="xref py py-data docutils literal"><span class="pre">pair_power_index</span></tt></a></li>
<li><a class="reference internal" href="#pair_qabs_index" title="pair_qabs_index"><tt class="xref py py-data docutils literal"><span class="pre">pair_qabs_index</span></tt></a></li>
<li><a class="reference internal" href="#pair_qexp_index" title="pair_qexp_index"><tt class="xref py py-data docutils literal"><span class="pre">pair_qexp_index</span></tt></a></li>
<li><a class="reference internal" href="#pair_qpair_index" title="pair_qpair_index"><tt class="xref py py-data docutils literal"><span class="pre">pair_qpair_index</span></tt></a></li>
<li><a class="reference internal" href="#pair_shift_index" title="pair_shift_index"><tt class="xref py py-data docutils literal"><span class="pre">pair_shift_index</span></tt></a></li>
<li><a class="reference internal" href="#pair_spring_index" title="pair_spring_index"><tt class="xref py py-data docutils literal"><span class="pre">pair_spring_index</span></tt></a></li>
<li><a class="reference internal" href="#pair_step_index" title="pair_step_index"><tt class="xref py py-data docutils literal"><span class="pre">pair_step_index</span></tt></a></li>
<li><a class="reference internal" href="#pair_table_index" title="pair_table_index"><tt class="xref py py-data docutils literal"><span class="pre">pair_table_index</span></tt></a></li>
<li><a class="reference internal" href="#param_name_length" title="param_name_length"><tt class="xref py py-data docutils literal"><span class="pre">param_name_length</span></tt></a></li>
<li><a class="reference internal" href="#param_note_length" title="param_note_length"><tt class="xref py py-data docutils literal"><span class="pre">param_note_length</span></tt></a></li>
<li><a class="reference internal" href="#pot_name_length" title="pot_name_length"><tt class="xref py py-data docutils literal"><span class="pre">pot_name_length</span></tt></a></li>
<li><a class="reference internal" href="#pot_note_length" title="pot_note_length"><tt class="xref py py-data docutils literal"><span class="pre">pot_note_length</span></tt></a></li>
<li><a class="reference internal" href="#potential_descriptors" title="potential_descriptors"><tt class="xref py py-data docutils literal"><span class="pre">potential_descriptors</span></tt></a></li>
<li><a class="reference internal" href="#power_index" title="power_index"><tt class="xref py py-data docutils literal"><span class="pre">power_index</span></tt></a></li>
<li><a class="reference internal" href="#quad_dihedral_index" title="quad_dihedral_index"><tt class="xref py py-data docutils literal"><span class="pre">quad_dihedral_index</span></tt></a></li>
<li><a class="reference internal" href="#s_factor" title="s_factor"><tt class="xref py py-data docutils literal"><span class="pre">s_factor</span></tt></a></li>
<li><a class="reference internal" href="#s_factor_allocated" title="s_factor_allocated"><tt class="xref py py-data docutils literal"><span class="pre">s_factor_allocated</span></tt></a></li>
<li><a class="reference internal" href="#sqrt_scale_index" title="sqrt_scale_index"><tt class="xref py py-data docutils literal"><span class="pre">sqrt_scale_index</span></tt></a></li>
<li><a class="reference internal" href="#stored_factor_cutoffs" title="stored_factor_cutoffs"><tt class="xref py py-data docutils literal"><span class="pre">stored_factor_cutoffs</span></tt></a></li>
<li><a class="reference internal" href="#table_bond_index" title="table_bond_index"><tt class="xref py py-data docutils literal"><span class="pre">table_bond_index</span></tt></a></li>
<li><a class="reference internal" href="#table_prefix" title="table_prefix"><tt class="xref py py-data docutils literal"><span class="pre">table_prefix</span></tt></a></li>
<li><a class="reference internal" href="#table_scale_index" title="table_scale_index"><tt class="xref py py-data docutils literal"><span class="pre">table_scale_index</span></tt></a></li>
<li><a class="reference internal" href="#table_suffix" title="table_suffix"><tt class="xref py py-data docutils literal"><span class="pre">table_suffix</span></tt></a></li>
<li><a class="reference internal" href="#tersoff_index" title="tersoff_index"><tt class="xref py py-data docutils literal"><span class="pre">tersoff_index</span></tt></a></li>
<li><a class="reference internal" href="#tmp_factor" title="tmp_factor"><tt class="xref py py-data docutils literal"><span class="pre">tmp_factor</span></tt></a></li>
<li><a class="reference internal" href="#tri_bend_index" title="tri_bend_index"><tt class="xref py py-data docutils literal"><span class="pre">tri_bend_index</span></tt></a></li>
<li><a class="reference internal" href="#triplet_index" title="triplet_index"><tt class="xref py py-data docutils literal"><span class="pre">triplet_index</span></tt></a></li>
</ul>
</div>
<div class="section" id="list-of-custom-types-in-potentials">
<h2>List of custom types in potentials<a class="headerlink" href="#list-of-custom-types-in-potentials" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference internal" href="#bond_order_descriptor" title="bond_order_descriptor"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_descriptor</span></tt></a></li>
<li><a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a></li>
<li><a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a></li>
<li><a class="reference internal" href="#potential_descriptor" title="potential_descriptor"><tt class="xref py py-data docutils literal"><span class="pre">potential_descriptor</span></tt></a></li>
</ul>
</div>
<div class="section" id="list-of-subroutines-in-potentials">
<h2>List of subroutines in potentials<a class="headerlink" href="#list-of-subroutines-in-potentials" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference internal" href="#allocate_ewald_arrays" title="allocate_ewald_arrays"><tt class="xref py py-func docutils literal"><span class="pre">allocate_ewald_arrays()</span></tt></a></li>
<li><a class="reference internal" href="#bond_order_factor_affects_atom" title="bond_order_factor_affects_atom"><tt class="xref py py-func docutils literal"><span class="pre">bond_order_factor_affects_atom()</span></tt></a></li>
<li><a class="reference internal" href="#bond_order_factor_is_in_group" title="bond_order_factor_is_in_group"><tt class="xref py py-func docutils literal"><span class="pre">bond_order_factor_is_in_group()</span></tt></a></li>
<li><a class="reference internal" href="#calculate_derived_parameters_bond_bending" title="calculate_derived_parameters_bond_bending"><tt class="xref py py-func docutils literal"><span class="pre">calculate_derived_parameters_bond_bending()</span></tt></a></li>
<li><a class="reference internal" href="#calculate_derived_parameters_charge_exp" title="calculate_derived_parameters_charge_exp"><tt class="xref py py-func docutils literal"><span class="pre">calculate_derived_parameters_charge_exp()</span></tt></a></li>
<li><a class="reference internal" href="#calculate_derived_parameters_dihedral" title="calculate_derived_parameters_dihedral"><tt class="xref py py-func docutils literal"><span class="pre">calculate_derived_parameters_dihedral()</span></tt></a></li>
<li><a class="reference internal" href="#calculate_ewald_electronegativities" title="calculate_ewald_electronegativities"><tt class="xref py py-func docutils literal"><span class="pre">calculate_ewald_electronegativities()</span></tt></a></li>
<li><a class="reference internal" href="#calculate_ewald_energy" title="calculate_ewald_energy"><tt class="xref py py-func docutils literal"><span class="pre">calculate_ewald_energy()</span></tt></a></li>
<li><a class="reference internal" href="#calculate_ewald_forces" title="calculate_ewald_forces"><tt class="xref py py-func docutils literal"><span class="pre">calculate_ewald_forces()</span></tt></a></li>
<li><a class="reference internal" href="#check_s_factor_array_allocation" title="check_s_factor_array_allocation"><tt class="xref py py-func docutils literal"><span class="pre">check_s_factor_array_allocation()</span></tt></a></li>
<li><a class="reference internal" href="#clear_bond_order_factor_characterizers" title="clear_bond_order_factor_characterizers"><tt class="xref py py-func docutils literal"><span class="pre">clear_bond_order_factor_characterizers()</span></tt></a></li>
<li><a class="reference internal" href="#clear_potential_characterizers" title="clear_potential_characterizers"><tt class="xref py py-func docutils literal"><span class="pre">clear_potential_characterizers()</span></tt></a></li>
<li><a class="reference internal" href="#create_bond_order_factor" title="create_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">create_bond_order_factor()</span></tt></a></li>
<li><a class="reference internal" href="#create_bond_order_factor_characterizer_coordination" title="create_bond_order_factor_characterizer_coordination"><tt class="xref py py-func docutils literal"><span class="pre">create_bond_order_factor_characterizer_coordination()</span></tt></a></li>
<li><a class="reference internal" href="#create_bond_order_factor_characterizer_power" title="create_bond_order_factor_characterizer_power"><tt class="xref py py-func docutils literal"><span class="pre">create_bond_order_factor_characterizer_power()</span></tt></a></li>
<li><a class="reference internal" href="#create_bond_order_factor_characterizer_scaler_1" title="create_bond_order_factor_characterizer_scaler_1"><tt class="xref py py-func docutils literal"><span class="pre">create_bond_order_factor_characterizer_scaler_1()</span></tt></a></li>
<li><a class="reference internal" href="#create_bond_order_factor_characterizer_scaler_sqrt" title="create_bond_order_factor_characterizer_scaler_sqrt"><tt class="xref py py-func docutils literal"><span class="pre">create_bond_order_factor_characterizer_scaler_sqrt()</span></tt></a></li>
<li><a class="reference internal" href="#create_bond_order_factor_characterizer_scaler_table" title="create_bond_order_factor_characterizer_scaler_table"><tt class="xref py py-func docutils literal"><span class="pre">create_bond_order_factor_characterizer_scaler_table()</span></tt></a></li>
<li><a class="reference internal" href="#create_bond_order_factor_characterizer_table" title="create_bond_order_factor_characterizer_table"><tt class="xref py py-func docutils literal"><span class="pre">create_bond_order_factor_characterizer_table()</span></tt></a></li>
<li><a class="reference internal" href="#create_bond_order_factor_characterizer_tersoff" title="create_bond_order_factor_characterizer_tersoff"><tt class="xref py py-func docutils literal"><span class="pre">create_bond_order_factor_characterizer_tersoff()</span></tt></a></li>
<li><a class="reference internal" href="#create_bond_order_factor_characterizer_triplet" title="create_bond_order_factor_characterizer_triplet"><tt class="xref py py-func docutils literal"><span class="pre">create_bond_order_factor_characterizer_triplet()</span></tt></a></li>
<li><a class="reference internal" href="#create_potential" title="create_potential"><tt class="xref py py-func docutils literal"><span class="pre">create_potential()</span></tt></a></li>
<li><a class="reference internal" href="#create_potential_characterizer_LJ" title="create_potential_characterizer_LJ"><tt class="xref py py-func docutils literal"><span class="pre">create_potential_characterizer_LJ()</span></tt></a></li>
<li><a class="reference internal" href="#create_potential_characterizer_bond_bending" title="create_potential_characterizer_bond_bending"><tt class="xref py py-func docutils literal"><span class="pre">create_potential_characterizer_bond_bending()</span></tt></a></li>
<li><a class="reference internal" href="#create_potential_characterizer_buckingham" title="create_potential_characterizer_buckingham"><tt class="xref py py-func docutils literal"><span class="pre">create_potential_characterizer_buckingham()</span></tt></a></li>
<li><a class="reference internal" href="#create_potential_characterizer_charge_exp" title="create_potential_characterizer_charge_exp"><tt class="xref py py-func docutils literal"><span class="pre">create_potential_characterizer_charge_exp()</span></tt></a></li>
<li><a class="reference internal" href="#create_potential_characterizer_charge_pair" title="create_potential_characterizer_charge_pair"><tt class="xref py py-func docutils literal"><span class="pre">create_potential_characterizer_charge_pair()</span></tt></a></li>
<li><a class="reference internal" href="#create_potential_characterizer_charge_pair_abs" title="create_potential_characterizer_charge_pair_abs"><tt class="xref py py-func docutils literal"><span class="pre">create_potential_characterizer_charge_pair_abs()</span></tt></a></li>
<li><a class="reference internal" href="#create_potential_characterizer_charge_self" title="create_potential_characterizer_charge_self"><tt class="xref py py-func docutils literal"><span class="pre">create_potential_characterizer_charge_self()</span></tt></a></li>
<li><a class="reference internal" href="#create_potential_characterizer_constant_force" title="create_potential_characterizer_constant_force"><tt class="xref py py-func docutils literal"><span class="pre">create_potential_characterizer_constant_force()</span></tt></a></li>
<li><a class="reference internal" href="#create_potential_characterizer_constant_potential" title="create_potential_characterizer_constant_potential"><tt class="xref py py-func docutils literal"><span class="pre">create_potential_characterizer_constant_potential()</span></tt></a></li>
<li><a class="reference internal" href="#create_potential_characterizer_dihedral" title="create_potential_characterizer_dihedral"><tt class="xref py py-func docutils literal"><span class="pre">create_potential_characterizer_dihedral()</span></tt></a></li>
<li><a class="reference internal" href="#create_potential_characterizer_exp" title="create_potential_characterizer_exp"><tt class="xref py py-func docutils literal"><span class="pre">create_potential_characterizer_exp()</span></tt></a></li>
<li><a class="reference internal" href="#create_potential_characterizer_power" title="create_potential_characterizer_power"><tt class="xref py py-func docutils literal"><span class="pre">create_potential_characterizer_power()</span></tt></a></li>
<li><a class="reference internal" href="#create_potential_characterizer_shift" title="create_potential_characterizer_shift"><tt class="xref py py-func docutils literal"><span class="pre">create_potential_characterizer_shift()</span></tt></a></li>
<li><a class="reference internal" href="#create_potential_characterizer_spring" title="create_potential_characterizer_spring"><tt class="xref py py-func docutils literal"><span class="pre">create_potential_characterizer_spring()</span></tt></a></li>
<li><a class="reference internal" href="#create_potential_characterizer_step" title="create_potential_characterizer_step"><tt class="xref py py-func docutils literal"><span class="pre">create_potential_characterizer_step()</span></tt></a></li>
<li><a class="reference internal" href="#create_potential_characterizer_table" title="create_potential_characterizer_table"><tt class="xref py py-func docutils literal"><span class="pre">create_potential_characterizer_table()</span></tt></a></li>
<li><a class="reference internal" href="#deallocate_ewald_arrays" title="deallocate_ewald_arrays"><tt class="xref py py-func docutils literal"><span class="pre">deallocate_ewald_arrays()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_bond_order_factor" title="evaluate_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_bond_order_factor()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_bond_order_factor_coordination" title="evaluate_bond_order_factor_coordination"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_bond_order_factor_coordination()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_bond_order_factor_power" title="evaluate_bond_order_factor_power"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_bond_order_factor_power()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_bond_order_factor_table" title="evaluate_bond_order_factor_table"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_bond_order_factor_table()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_bond_order_factor_triplet" title="evaluate_bond_order_factor_triplet"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_bond_order_factor_triplet()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_bond_order_gradient" title="evaluate_bond_order_gradient"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_bond_order_gradient()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_bond_order_gradient_coordination" title="evaluate_bond_order_gradient_coordination"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_bond_order_gradient_coordination()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_bond_order_gradient_power" title="evaluate_bond_order_gradient_power"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_bond_order_gradient_power()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_bond_order_gradient_table" title="evaluate_bond_order_gradient_table"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_bond_order_gradient_table()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_bond_order_gradient_triplet" title="evaluate_bond_order_gradient_triplet"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_bond_order_gradient_triplet()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_electronegativity" title="evaluate_electronegativity"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_electronegativity()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_electronegativity_charge_exp" title="evaluate_electronegativity_charge_exp"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_electronegativity_charge_exp()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_electronegativity_charge_pair" title="evaluate_electronegativity_charge_pair"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_electronegativity_charge_pair()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_electronegativity_charge_pair_abs" title="evaluate_electronegativity_charge_pair_abs"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_electronegativity_charge_pair_abs()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_electronegativity_charge_self" title="evaluate_electronegativity_charge_self"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_electronegativity_charge_self()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_electronegativity_component" title="evaluate_electronegativity_component"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_electronegativity_component()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_energy" title="evaluate_energy"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_energy()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_energy_LJ" title="evaluate_energy_LJ"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_energy_LJ()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_energy_bond_bending" title="evaluate_energy_bond_bending"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_energy_bond_bending()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_energy_buckingham" title="evaluate_energy_buckingham"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_energy_buckingham()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_energy_charge_exp" title="evaluate_energy_charge_exp"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_energy_charge_exp()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_energy_charge_pair" title="evaluate_energy_charge_pair"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_energy_charge_pair()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_energy_charge_pair_abs" title="evaluate_energy_charge_pair_abs"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_energy_charge_pair_abs()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_energy_charge_self" title="evaluate_energy_charge_self"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_energy_charge_self()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_energy_component" title="evaluate_energy_component"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_energy_component()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_energy_constant_force" title="evaluate_energy_constant_force"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_energy_constant_force()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_energy_constant_potential" title="evaluate_energy_constant_potential"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_energy_constant_potential()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_energy_dihedral" title="evaluate_energy_dihedral"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_energy_dihedral()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_energy_exp" title="evaluate_energy_exp"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_energy_exp()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_energy_power" title="evaluate_energy_power"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_energy_power()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_energy_shift" title="evaluate_energy_shift"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_energy_shift()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_energy_spring" title="evaluate_energy_spring"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_energy_spring()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_energy_step" title="evaluate_energy_step"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_energy_step()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_energy_table" title="evaluate_energy_table"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_energy_table()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_force_LJ" title="evaluate_force_LJ"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_force_LJ()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_force_bond_bending" title="evaluate_force_bond_bending"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_force_bond_bending()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_force_buckingham" title="evaluate_force_buckingham"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_force_buckingham()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_force_component" title="evaluate_force_component"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_force_component()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_force_constant_force" title="evaluate_force_constant_force"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_force_constant_force()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_force_constant_potential" title="evaluate_force_constant_potential"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_force_constant_potential()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_force_dihedral" title="evaluate_force_dihedral"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_force_dihedral()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_force_exp" title="evaluate_force_exp"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_force_exp()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_force_power" title="evaluate_force_power"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_force_power()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_force_shift" title="evaluate_force_shift"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_force_shift()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_force_spring" title="evaluate_force_spring"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_force_spring()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_force_step" title="evaluate_force_step"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_force_step()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_force_table" title="evaluate_force_table"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_force_table()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_forces" title="evaluate_forces"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_forces()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_pair_bond_order_factor" title="evaluate_pair_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_pair_bond_order_factor()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_pair_bond_order_factor_tersoff" title="evaluate_pair_bond_order_factor_tersoff"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_pair_bond_order_factor_tersoff()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_pair_bond_order_gradient" title="evaluate_pair_bond_order_gradient"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_pair_bond_order_gradient()</span></tt></a></li>
<li><a class="reference internal" href="#evaluate_pair_bond_order_gradient_tersoff" title="evaluate_pair_bond_order_gradient_tersoff"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_pair_bond_order_gradient_tersoff()</span></tt></a></li>
<li><a class="reference internal" href="#get_bond_descriptor" title="get_bond_descriptor"><tt class="xref py py-func docutils literal"><span class="pre">get_bond_descriptor()</span></tt></a></li>
<li><a class="reference internal" href="#get_description_of_bond_order_factor" title="get_description_of_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">get_description_of_bond_order_factor()</span></tt></a></li>
<li><a class="reference internal" href="#get_description_of_potential" title="get_description_of_potential"><tt class="xref py py-func docutils literal"><span class="pre">get_description_of_potential()</span></tt></a></li>
<li><a class="reference internal" href="#get_descriptions_of_parameters_of_bond_order_factor" title="get_descriptions_of_parameters_of_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">get_descriptions_of_parameters_of_bond_order_factor()</span></tt></a></li>
<li><a class="reference internal" href="#get_descriptions_of_parameters_of_potential" title="get_descriptions_of_parameters_of_potential"><tt class="xref py py-func docutils literal"><span class="pre">get_descriptions_of_parameters_of_potential()</span></tt></a></li>
<li><a class="reference internal" href="#get_descriptor" title="get_descriptor"><tt class="xref py py-func docutils literal"><span class="pre">get_descriptor()</span></tt></a></li>
<li><a class="reference internal" href="#get_index_of_bond_order_factor" title="get_index_of_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">get_index_of_bond_order_factor()</span></tt></a></li>
<li><a class="reference internal" href="#get_index_of_parameter_of_bond_order_factor" title="get_index_of_parameter_of_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">get_index_of_parameter_of_bond_order_factor()</span></tt></a></li>
<li><a class="reference internal" href="#get_index_of_parameter_of_potential" title="get_index_of_parameter_of_potential"><tt class="xref py py-func docutils literal"><span class="pre">get_index_of_parameter_of_potential()</span></tt></a></li>
<li><a class="reference internal" href="#get_index_of_potential" title="get_index_of_potential"><tt class="xref py py-func docutils literal"><span class="pre">get_index_of_potential()</span></tt></a></li>
<li><a class="reference internal" href="#get_level_of_bond_order_factor" title="get_level_of_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">get_level_of_bond_order_factor()</span></tt></a></li>
<li><a class="reference internal" href="#get_level_of_bond_order_factor_index" title="get_level_of_bond_order_factor_index"><tt class="xref py py-func docutils literal"><span class="pre">get_level_of_bond_order_factor_index()</span></tt></a></li>
<li><a class="reference internal" href="#get_names_of_parameters_of_bond_order_factor" title="get_names_of_parameters_of_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">get_names_of_parameters_of_bond_order_factor()</span></tt></a></li>
<li><a class="reference internal" href="#get_names_of_parameters_of_potential" title="get_names_of_parameters_of_potential"><tt class="xref py py-func docutils literal"><span class="pre">get_names_of_parameters_of_potential()</span></tt></a></li>
<li><a class="reference internal" href="#get_number_of_bond_order_factors" title="get_number_of_bond_order_factors"><tt class="xref py py-func docutils literal"><span class="pre">get_number_of_bond_order_factors()</span></tt></a></li>
<li><a class="reference internal" href="#get_number_of_parameters_of_bond_order_factor" title="get_number_of_parameters_of_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">get_number_of_parameters_of_bond_order_factor()</span></tt></a></li>
<li><a class="reference internal" href="#get_number_of_parameters_of_potential" title="get_number_of_parameters_of_potential"><tt class="xref py py-func docutils literal"><span class="pre">get_number_of_parameters_of_potential()</span></tt></a></li>
<li><a class="reference internal" href="#get_number_of_potentials" title="get_number_of_potentials"><tt class="xref py py-func docutils literal"><span class="pre">get_number_of_potentials()</span></tt></a></li>
<li><a class="reference internal" href="#get_number_of_targets_of_bond_order_factor" title="get_number_of_targets_of_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">get_number_of_targets_of_bond_order_factor()</span></tt></a></li>
<li><a class="reference internal" href="#get_number_of_targets_of_bond_order_factor_index" title="get_number_of_targets_of_bond_order_factor_index"><tt class="xref py py-func docutils literal"><span class="pre">get_number_of_targets_of_bond_order_factor_index()</span></tt></a></li>
<li><a class="reference internal" href="#get_number_of_targets_of_potential" title="get_number_of_targets_of_potential"><tt class="xref py py-func docutils literal"><span class="pre">get_number_of_targets_of_potential()</span></tt></a></li>
<li><a class="reference internal" href="#get_number_of_targets_of_potential_index" title="get_number_of_targets_of_potential_index"><tt class="xref py py-func docutils literal"><span class="pre">get_number_of_targets_of_potential_index()</span></tt></a></li>
<li><a class="reference internal" href="#initialize_bond_order_factor_characterizers" title="initialize_bond_order_factor_characterizers"><tt class="xref py py-func docutils literal"><span class="pre">initialize_bond_order_factor_characterizers()</span></tt></a></li>
<li><a class="reference internal" href="#initialize_potential_characterizers" title="initialize_potential_characterizers"><tt class="xref py py-func docutils literal"><span class="pre">initialize_potential_characterizers()</span></tt></a></li>
<li><a class="reference internal" href="#is_valid_bond_order_factor" title="is_valid_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">is_valid_bond_order_factor()</span></tt></a></li>
<li><a class="reference internal" href="#is_valid_potential" title="is_valid_potential"><tt class="xref py py-func docutils literal"><span class="pre">is_valid_potential()</span></tt></a></li>
<li><a class="reference internal" href="#list_bond_order_factors" title="list_bond_order_factors"><tt class="xref py py-func docutils literal"><span class="pre">list_bond_order_factors()</span></tt></a></li>
<li><a class="reference internal" href="#list_potentials" title="list_potentials"><tt class="xref py py-func docutils literal"><span class="pre">list_potentials()</span></tt></a></li>
<li><a class="reference internal" href="#post_process_bond_order_factor" title="post_process_bond_order_factor"><tt class="xref py py-func docutils literal"><span class="pre">post_process_bond_order_factor()</span></tt></a></li>
<li><a class="reference internal" href="#post_process_bond_order_factor_scaler_1" title="post_process_bond_order_factor_scaler_1"><tt class="xref py py-func docutils literal"><span class="pre">post_process_bond_order_factor_scaler_1()</span></tt></a></li>
<li><a class="reference internal" href="#post_process_bond_order_factor_scaler_sqrt" title="post_process_bond_order_factor_scaler_sqrt"><tt class="xref py py-func docutils literal"><span class="pre">post_process_bond_order_factor_scaler_sqrt()</span></tt></a></li>
<li><a class="reference internal" href="#post_process_bond_order_factor_scaler_table" title="post_process_bond_order_factor_scaler_table"><tt class="xref py py-func docutils literal"><span class="pre">post_process_bond_order_factor_scaler_table()</span></tt></a></li>
<li><a class="reference internal" href="#post_process_bond_order_factor_tersoff" title="post_process_bond_order_factor_tersoff"><tt class="xref py py-func docutils literal"><span class="pre">post_process_bond_order_factor_tersoff()</span></tt></a></li>
<li><a class="reference internal" href="#post_process_bond_order_gradient" title="post_process_bond_order_gradient"><tt class="xref py py-func docutils literal"><span class="pre">post_process_bond_order_gradient()</span></tt></a></li>
<li><a class="reference internal" href="#post_process_bond_order_gradient_scaler_1" title="post_process_bond_order_gradient_scaler_1"><tt class="xref py py-func docutils literal"><span class="pre">post_process_bond_order_gradient_scaler_1()</span></tt></a></li>
<li><a class="reference internal" href="#post_process_bond_order_gradient_scaler_sqrt" title="post_process_bond_order_gradient_scaler_sqrt"><tt class="xref py py-func docutils literal"><span class="pre">post_process_bond_order_gradient_scaler_sqrt()</span></tt></a></li>
<li><a class="reference internal" href="#post_process_bond_order_gradient_scaler_table" title="post_process_bond_order_gradient_scaler_table"><tt class="xref py py-func docutils literal"><span class="pre">post_process_bond_order_gradient_scaler_table()</span></tt></a></li>
<li><a class="reference internal" href="#post_process_bond_order_gradient_tersoff" title="post_process_bond_order_gradient_tersoff"><tt class="xref py py-func docutils literal"><span class="pre">post_process_bond_order_gradient_tersoff()</span></tt></a></li>
<li><a class="reference internal" href="#potential_affects_atom" title="potential_affects_atom"><tt class="xref py py-func docutils literal"><span class="pre">potential_affects_atom()</span></tt></a></li>
<li><a class="reference internal" href="#smoothening_derivative" title="smoothening_derivative"><tt class="xref py py-func docutils literal"><span class="pre">smoothening_derivative()</span></tt></a></li>
<li><a class="reference internal" href="#smoothening_factor" title="smoothening_factor"><tt class="xref py py-func docutils literal"><span class="pre">smoothening_factor()</span></tt></a></li>
<li><a class="reference internal" href="#smoothening_gradient" title="smoothening_gradient"><tt class="xref py py-func docutils literal"><span class="pre">smoothening_gradient()</span></tt></a></li>
</ul>
</div>
<div class="section" id="full-documentation-of-global-variables-in-potentials">
<h2>Full documentation of global variables in potentials<a class="headerlink" href="#full-documentation-of-global-variables-in-potentials" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><dl class="data">
<dt id="bond_descriptors_created">
<tt class="descname">bond_descriptors_created</tt><a class="headerlink" href="#bond_descriptors_created" title="Permalink to this definition">¶</a></dt>
<dd><p>logical    <em>scalar</em></p>
<p><em>initial value</em> = .false.</p>
<p>logical tag used for managing pointer allocations for bond order factor descriptors</p>
</dd></dl>

<dl class="data">
<dt id="bond_order_descriptors">
<tt class="descname">bond_order_descriptors</tt><a class="headerlink" href="#bond_order_descriptors" title="Permalink to this definition">¶</a></dt>
<dd><p>type(bond_order_descriptor)  <em>pointer</em>  <em>size(:)</em></p>
<p>an array for storing descriptors for the different <em>types</em> of bond order factors</p>
</dd></dl>

<dl class="data">
<dt id="c_scale_index">
<tt class="descname">c_scale_index</tt><a class="headerlink" href="#c_scale_index" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 3</p>
<p>internal index for the coordination scaling function</p>
</dd></dl>

<dl class="data">
<dt id="coordination_index">
<tt class="descname">coordination_index</tt><a class="headerlink" href="#coordination_index" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 1</p>
</dd></dl>

<dl class="data">
<dt id="descriptors_created">
<tt class="descname">descriptors_created</tt><a class="headerlink" href="#descriptors_created" title="Permalink to this definition">¶</a></dt>
<dd><p>logical    <em>scalar</em></p>
<p><em>initial value</em> = .false.</p>
<p>logical tag used for managing pointer allocations for potential descriptors</p>
</dd></dl>

<dl class="data">
<dt id="ewald_arrays_allocated">
<tt class="descname">ewald_arrays_allocated</tt><a class="headerlink" href="#ewald_arrays_allocated" title="Permalink to this definition">¶</a></dt>
<dd><p>logical    <em>scalar</em></p>
<p><em>initial value</em> = .false.</p>
</dd></dl>

<dl class="data">
<dt id="ewald_forces">
<tt class="descname">ewald_forces</tt><a class="headerlink" href="#ewald_forces" title="Permalink to this definition">¶</a></dt>
<dd><p>double precision  <em>pointer</em>  <em>size(:, :, :)</em></p>
</dd></dl>

<dl class="data">
<dt id="ewald_sum_forces">
<tt class="descname">ewald_sum_forces</tt><a class="headerlink" href="#ewald_sum_forces" title="Permalink to this definition">¶</a></dt>
<dd><p>double precision  <em>pointer</em>  <em>size(:, :, :)</em></p>
</dd></dl>

<dl class="data">
<dt id="ewald_tmp_enegs">
<tt class="descname">ewald_tmp_enegs</tt><a class="headerlink" href="#ewald_tmp_enegs" title="Permalink to this definition">¶</a></dt>
<dd><p>double precision  <em>pointer</em>  <em>size(:)</em></p>
</dd></dl>

<dl class="data">
<dt id="mono_const_index">
<tt class="descname">mono_const_index</tt><a class="headerlink" href="#mono_const_index" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 3</p>
<p>internal index for the constant force potential</p>
</dd></dl>

<dl class="data">
<dt id="mono_none_index">
<tt class="descname">mono_none_index</tt><a class="headerlink" href="#mono_none_index" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 6</p>
<p>internal index for the constant potential</p>
</dd></dl>

<dl class="data">
<dt id="mono_qself_index">
<tt class="descname">mono_qself_index</tt><a class="headerlink" href="#mono_qself_index" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 11</p>
</dd></dl>

<dl class="data">
<dt id="n_bond_order_types">
<tt class="descname">n_bond_order_types</tt><a class="headerlink" href="#n_bond_order_types" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 8</p>
<p>number of different types of bond order factors known</p>
</dd></dl>

<dl class="data">
<dt id="n_max_params">
<tt class="descname">n_max_params</tt><a class="headerlink" href="#n_max_params" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 12</p>
</dd></dl>

<dl class="data">
<dt id="n_potential_types">
<tt class="descname">n_potential_types</tt><a class="headerlink" href="#n_potential_types" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 16</p>
<p>number of different types of potentials known</p>
</dd></dl>

<dl class="data">
<dt id="no_name">
<tt class="descname">no_name</tt><a class="headerlink" href="#no_name" title="Permalink to this definition">¶</a></dt>
<dd><p>character(len=label_length)    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = &#8220;xx&#8221;</p>
<p>The label for unlabeled atoms. In other words, there are routines that expect atomic symbols as arguments, but if there are no symbols to pass, this should be given to mark an empty entry.</p>
</dd></dl>

<dl class="data">
<dt id="pair_buck_index">
<tt class="descname">pair_buck_index</tt><a class="headerlink" href="#pair_buck_index" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 7</p>
<p>internal index for the Buckingham potential</p>
</dd></dl>

<dl class="data">
<dt id="pair_exp_index">
<tt class="descname">pair_exp_index</tt><a class="headerlink" href="#pair_exp_index" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 5</p>
</dd></dl>

<dl class="data">
<dt id="pair_lj_index">
<tt class="descname">pair_lj_index</tt><a class="headerlink" href="#pair_lj_index" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 1</p>
<p>internal index for the Lennard-Jones potential</p>
</dd></dl>

<dl class="data">
<dt id="pair_power_index">
<tt class="descname">pair_power_index</tt><a class="headerlink" href="#pair_power_index" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 9</p>
<p>internal index for the power law potential</p>
</dd></dl>

<dl class="data">
<dt id="pair_qabs_index">
<tt class="descname">pair_qabs_index</tt><a class="headerlink" href="#pair_qabs_index" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 14</p>
</dd></dl>

<dl class="data">
<dt id="pair_qexp_index">
<tt class="descname">pair_qexp_index</tt><a class="headerlink" href="#pair_qexp_index" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 13</p>
</dd></dl>

<dl class="data">
<dt id="pair_qpair_index">
<tt class="descname">pair_qpair_index</tt><a class="headerlink" href="#pair_qpair_index" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 12</p>
</dd></dl>

<dl class="data">
<dt id="pair_shift_index">
<tt class="descname">pair_shift_index</tt><a class="headerlink" href="#pair_shift_index" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 15</p>
</dd></dl>

<dl class="data">
<dt id="pair_spring_index">
<tt class="descname">pair_spring_index</tt><a class="headerlink" href="#pair_spring_index" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 2</p>
<p>internal index for the spring potential</p>
</dd></dl>

<dl class="data">
<dt id="pair_step_index">
<tt class="descname">pair_step_index</tt><a class="headerlink" href="#pair_step_index" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 16</p>
</dd></dl>

<dl class="data">
<dt id="pair_table_index">
<tt class="descname">pair_table_index</tt><a class="headerlink" href="#pair_table_index" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 10</p>
<p>internal index for the tabulated potential</p>
</dd></dl>

<dl class="data">
<dt id="param_name_length">
<tt class="descname">param_name_length</tt><a class="headerlink" href="#param_name_length" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 10</p>
</dd></dl>

<dl class="data">
<dt id="param_note_length">
<tt class="descname">param_note_length</tt><a class="headerlink" href="#param_note_length" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 100</p>
<p>maximum length allowed for the descriptions of parameters</p>
</dd></dl>

<dl class="data">
<dt id="pot_name_length">
<tt class="descname">pot_name_length</tt><a class="headerlink" href="#pot_name_length" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 11</p>
<p>maximum length allowed for the names of potentials</p>
</dd></dl>

<dl class="data">
<dt id="pot_note_length">
<tt class="descname">pot_note_length</tt><a class="headerlink" href="#pot_note_length" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 500</p>
<p>maximum lenght allowed for the description of the potential</p>
</dd></dl>

<dl class="data">
<dt id="potential_descriptors">
<tt class="descname">potential_descriptors</tt><a class="headerlink" href="#potential_descriptors" title="Permalink to this definition">¶</a></dt>
<dd><p>type(potential_descriptor)  <em>pointer</em>  <em>size(:)</em></p>
<p>an array for storing descriptors for the different <em>types</em> of potentials</p>
</dd></dl>

<dl class="data">
<dt id="power_index">
<tt class="descname">power_index</tt><a class="headerlink" href="#power_index" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 5</p>
<p>internal index for the power law bond order factor</p>
</dd></dl>

<dl class="data">
<dt id="quad_dihedral_index">
<tt class="descname">quad_dihedral_index</tt><a class="headerlink" href="#quad_dihedral_index" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 8</p>
<p>internal index for the dihedral angle potential</p>
</dd></dl>

<dl class="data">
<dt id="s_factor">
<tt class="descname">s_factor</tt><a class="headerlink" href="#s_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>double precision  <em>pointer</em>  <em>size(:, :, :, :)</em></p>
</dd></dl>

<dl class="data">
<dt id="s_factor_allocated">
<tt class="descname">s_factor_allocated</tt><a class="headerlink" href="#s_factor_allocated" title="Permalink to this definition">¶</a></dt>
<dd><p>logical    <em>scalar</em></p>
<p><em>initial value</em> = .false.</p>
</dd></dl>

<dl class="data">
<dt id="sqrt_scale_index">
<tt class="descname">sqrt_scale_index</tt><a class="headerlink" href="#sqrt_scale_index" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 6</p>
<p>internal index for the square root scaling function</p>
</dd></dl>

<dl class="data">
<dt id="stored_factor_cutoffs">
<tt class="descname">stored_factor_cutoffs</tt><a class="headerlink" href="#stored_factor_cutoffs" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>size(3)</em></p>
</dd></dl>

<dl class="data">
<dt id="table_bond_index">
<tt class="descname">table_bond_index</tt><a class="headerlink" href="#table_bond_index" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 7</p>
<p>internal index for the tabulated bond order factor</p>
</dd></dl>

<dl class="data">
<dt id="table_prefix">
<tt class="descname">table_prefix</tt><a class="headerlink" href="#table_prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>character(len=6)    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = &#8220;<a href="#id3"><span class="problematic" id="id4">table_</span></a>&#8220;</p>
<p>prefix for filenames for storing tables</p>
</dd></dl>

<dl class="data">
<dt id="table_scale_index">
<tt class="descname">table_scale_index</tt><a class="headerlink" href="#table_scale_index" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 8</p>
<p>internal index for the tabulated scaling function</p>
</dd></dl>

<dl class="data">
<dt id="table_suffix">
<tt class="descname">table_suffix</tt><a class="headerlink" href="#table_suffix" title="Permalink to this definition">¶</a></dt>
<dd><p>character(len=4)    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = &#8221;.txt&#8221;</p>
</dd></dl>

<dl class="data">
<dt id="tersoff_index">
<tt class="descname">tersoff_index</tt><a class="headerlink" href="#tersoff_index" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 2</p>
<p>internal index for the Tersoff bond order factor</p>
</dd></dl>

<dl class="data">
<dt id="tmp_factor">
<tt class="descname">tmp_factor</tt><a class="headerlink" href="#tmp_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>double precision  <em>pointer</em>  <em>size(:, :, :, :)</em></p>
</dd></dl>

<dl class="data">
<dt id="tri_bend_index">
<tt class="descname">tri_bend_index</tt><a class="headerlink" href="#tri_bend_index" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 4</p>
<p>internal index for the bond bending potential</p>
</dd></dl>

<dl class="data">
<dt id="triplet_index">
<tt class="descname">triplet_index</tt><a class="headerlink" href="#triplet_index" title="Permalink to this definition">¶</a></dt>
<dd><p>integer    <em>scalar</em>  <em>parameter</em></p>
<p><em>initial value</em> = 4</p>
<p>internal index for the triplet bond order factor</p>
</dd></dl>

</div></blockquote>
</div>
<div class="section" id="full-documentation-of-custom-types-in-potentials">
<h2>Full documentation of custom types in potentials<a class="headerlink" href="#full-documentation-of-custom-types-in-potentials" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><dl class="data">
<dt id="bond_order_descriptor">
<tt class="descname">bond_order_descriptor</tt><a class="headerlink" href="#bond_order_descriptor" title="Permalink to this definition">¶</a></dt>
<dd><p>Description of a type of a bond order factor.
The type contains the name and description of the bond order factor
and the parameters it contains.
The descriptors contain the information that the inquiry methods in
the python interface fetch.</p>
<p>Contained data:</p>
<dl class="docutils">
<dt>parameter_notes: character(len=param_note_length)  <em>pointer</em>  <em>size(:, :)</em></dt>
<dd>Descriptions of the parameters. The descriptions should be very short indicators such as &#8216;spring constant&#8217; or &#8216;energy coefficient&#8217;. For more detailed explanations, the proper documentation should be used.</dd>
<dt>n_parameters: integer  <em>pointer</em>  <em>size(:)</em></dt>
<dd>number of parameters for each number of bodies (1-body parameters, 2-body parameters etc.)</dd>
<dt>n_level: integer    <em>scalar</em></dt>
<dd>1 for atomic bond order factors, 2 for pairwise factors</dd>
<dt>name: character(len=pot_name_length)    <em>scalar</em></dt>
<dd>The name of the bond order factor: this is a keyword according to which the factor may be recognized.</dd>
<dt>description: character(len=pot_note_length)    <em>scalar</em></dt>
<dd>A description of the bond order factor. This should contain the mathematical formulation as well as a short verbal explanation.</dd>
<dt>includes_post_processing: logical    <em>scalar</em></dt>
<dd>a logical tag specifying if there is a scaling function <span class="math">\(s_i\)</span> attached to the factor.</dd>
<dt>type_index: integer    <em>scalar</em></dt>
<dd>The internal index of the bond order factor. This can also be used for recognizing the factor and must therefore match the name. For instance, if name = &#8216;neighbors&#8217;, type_index = <a class="reference internal" href="#coordination_index" title="coordination_index"><tt class="xref py py-data docutils literal"><span class="pre">coordination_index</span></tt></a>.</dd>
<dt>n_targets: integer    <em>scalar</em></dt>
<dd>number of targets, i.e., interacting bodies</dd>
<dt>parameter_names: character(len=param_name_length)  <em>pointer</em>  <em>size(:, :)</em></dt>
<dd>The names of the parameters of the bond order factor: these are keywords according to which the parameters may be recognized.</dd>
</dl>
</dd></dl>

<dl class="data">
<dt id="bond_order_parameters">
<tt class="descname">bond_order_parameters</tt><a class="headerlink" href="#bond_order_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a particular bond order factor.
The factor should correspond to the description of some
built-in type and hold actual numeric values for parameters.
In addition a real bond order factor must have information on the
particles it acts on and the range it operates in.
These are created based on the <tt class="xref py py-class docutils literal"><span class="pre">BondOrderParameters</span></tt> objects in the Python
interface when calculations are invoked.</p>
<p>Contained data:</p>
<dl class="docutils">
<dt>cutoff: double precision    <em>scalar</em></dt>
<dd>The hard cutoff for the bond order factor. If the atoms are farther away from each other than this, they do not contribute to the total bond order factor does not affect them.</dd>
<dt>n_level: integer    <em>scalar</em></dt>
<dd>1 for atomic bond order factors, 2 for pairwise</dd>
<dt>soft_cutoff: double precision    <em>scalar</em></dt>
<dd>The soft cutoff for the bond order factor. If this is smaller than the hard cutoff, the bond contribution is scaled to zero continuously when the interatomic distances grow from the soft to the hard cutoff.</dd>
<dt>parameters: double precision  <em>pointer</em>  <em>size(:, :)</em></dt>
<dd>numerical values for parameters</dd>
<dt>group_index: integer    <em>scalar</em></dt>
<dd>The internal index of the <em>potential</em> the bond order factor is modifying.</dd>
<dt>includes_post_processing: logical    <em>scalar</em></dt>
<dd>a logical switch specifying if there is a scaling function <span class="math">\(s_i\)</span> attached to the factor</dd>
<dt>type_index: integer    <em>scalar</em></dt>
<dd>The internal index of the bond order factor <em>type</em>. This is used for recognizing the factor. Note that the bond order parameters instance does not have a name. If the name is needed, it can be obtained from the <a class="reference internal" href="#bond_order_descriptor" title="bond_order_descriptor"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_descriptor</span></tt></a> of the correct index.</dd>
<dt>n_params: integer  <em>pointer</em>  <em>size(:)</em></dt>
<dd>array containing the numbers of parameters for different number of targets (1-body parameters, 2-body parameters, etc.)</dd>
<dt>table: double precision  <em>pointer</em>  <em>size(:, :)</em></dt>
<dd>array for storing tabulated values</dd>
<dt>original_elements: character(len=2)  <em>pointer</em>  <em>size(:)</em></dt>
<dd>The list of elements (atomic symbols) of the original <tt class="xref py py-class docutils literal"><span class="pre">BondOrderParameters</span></tt> in the Python interface from which this factor was created. Whereas the apply_elements lists are used for finding all pairs and triplets of atoms which could contribute to the bond order factor, the original_elements lists specify the roles of atoms in the factor.</dd>
<dt>derived_parameters: double precision  <em>pointer</em>  <em>size(:, :)</em></dt>
<dd>numerical values for parameters calculated based on the parameters specified by the user</dd>
<dt>apply_elements: character(len=2)  <em>pointer</em>  <em>size(:)</em></dt>
<dd>A list of elements (atomic symbols) the factor affects. E.g., for Si-O bonds, it would be (&#8216;Si&#8217;,&#8217;O&#8217;). Note that unlike in the Python interface, a single <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> only has one set of targets, and for multiple target options several <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> instances are created.</dd>
</dl>
</dd></dl>

<dl class="data">
<dt id="potential">
<tt class="descname">potential</tt><a class="headerlink" href="#potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a particular potential.
The potential should correspond to the description of some
built-in type and hold actual numeric values for parameters.
In addition, a real potential must have information on the
particles it acts on and the range it operates in.
These are to be created based on the <tt class="xref py py-class docutils literal"><span class="pre">Potential</span></tt> objects in the Python
interface when calculations are invoked.</p>
<p>Contained data:</p>
<dl class="docutils">
<dt>pot_index: integer    <em>scalar</em></dt>
<dd>The internal index of the <em>actual potential</em>. This is needed when bond order factors are included so that the factors may be joint with the correct potentials.</dd>
<dt>smoothened: logical    <em>scalar</em></dt>
<dd>logical switch specifying if a smooth cutoff is applied to the potential</dd>
<dt>n_product: integer    <em>scalar</em></dt>
<dd>number of multipliers for a product potential</dd>
<dt>filter_elements: logical    <em>scalar</em></dt>
<dd>a logical switch specifying whether the potential targets atoms based on the atomic symbols</dd>
<dt>parameters: double precision  <em>pointer</em>  <em>size(:)</em></dt>
<dd>numerical values for parameters</dd>
<dt>cutoff: double precision    <em>scalar</em></dt>
<dd>The hard cutoff for the potential. If the atoms are farther away from each other than this, the potential does not affect them.</dd>
<dt>soft_cutoff: double precision    <em>scalar</em></dt>
<dd>The soft cutoff for the potential. If this is smaller than the hard cutoff, the potential is scaled to zero continuously when the interatomic distances grow from the soft to the hard cutoff.</dd>
<dt>apply_tags: integer  <em>pointer</em>  <em>size(:)</em></dt>
<dd>A list of atom tags the potential affects. Note that unlike in the Python interface, a single <a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a> only has one set of targets, and for multiple target options several <a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a> instances are created.</dd>
<dt>original_indices: integer  <em>pointer</em>  <em>size(:)</em></dt>
<dd>The list of atom indices of the original <tt class="xref py py-class docutils literal"><span class="pre">Potential</span></tt> in the Python interface from which this potential was created. Whereas the apply_* lists are used for finding all pairs and triplets of atoms for which the potential could act on, the original_* lists specify the roles of atoms in the interaction.</dd>
<dt>apply_indices: integer  <em>pointer</em>  <em>size(:)</em></dt>
<dd>A list of atom indices the potential affects. Note that unlike in the Python interface, a single <a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a> only has one set of targets, and for multiple target options several <a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a> instances are created.</dd>
<dt>filter_indices: logical    <em>scalar</em></dt>
<dd>a logical switch specifying whether the potential targets atoms based on the atom indices</dd>
<dt>type_index: integer    <em>scalar</em></dt>
<dd>The internal index of the potential <em>type</em>. This is used for recognizing the potential. Note that the potential instance does not have a name. If the name is needed, it can be obtained from the <a class="reference internal" href="#potential_descriptor" title="potential_descriptor"><tt class="xref py py-data docutils literal"><span class="pre">potential_descriptor</span></tt></a> of the correct index.</dd>
<dt>original_tags: integer  <em>pointer</em>  <em>size(:)</em></dt>
<dd>The list of atom tags of the original <tt class="xref py py-class docutils literal"><span class="pre">Potential</span></tt> in the Python interface from which this potential was created. Whereas the apply_* lists are used for finding all pairs and triplets of atoms for which the potential could act on, the original_* lists specify the roles of atoms in the interaction.</dd>
<dt>table: double precision  <em>pointer</em>  <em>size(:, :)</em></dt>
<dd>array for storing tabulated values</dd>
<dt>original_elements: character(len=2)  <em>pointer</em>  <em>size(:)</em></dt>
<dd>The list of elements (atomic symbols) of the original <tt class="xref py py-class docutils literal"><span class="pre">Potential</span></tt> in the Python interface from which this potential was created. Whereas the apply_* lists are used for finding all pairs and triplets of atoms for which the potential could act on, the original_* lists specify the roles of atoms in the interaction.</dd>
<dt>multipliers: type(potential)  <em>pointer</em>  <em>size(:)</em></dt>
<dd>additional potentials with the same targets and cutoff, for potential multiplication</dd>
<dt>derived_parameters: double precision  <em>pointer</em>  <em>size(:)</em></dt>
<dd>numerical values for parameters calculated based on the parameters specified by the user</dd>
<dt>apply_elements: character(len=2)  <em>pointer</em>  <em>size(:)</em></dt>
<dd>A list of elements (atomic symbols) the potential affects. E.g., for a Si-O potential, it would be (&#8216;Si&#8217;,&#8217;O&#8217;). Note that unlike in the Python interface, a single <a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a> only has one set of targets, and for multiple target options several <a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a> instances are created.</dd>
<dt>filter_tags: logical    <em>scalar</em></dt>
<dd>a logical switch specifying whether the potential targets atoms based on the atom tags</dd>
</dl>
</dd></dl>

<dl class="data">
<dt id="potential_descriptor">
<tt class="descname">potential_descriptor</tt><a class="headerlink" href="#potential_descriptor" title="Permalink to this definition">¶</a></dt>
<dd><p>Description of a type of a potential.
The type contains the name and description of the potential
and the parameters it contains.
The descriptors contain the information that the inquiry methods in
the python interface fetch.</p>
<p>Contained data:</p>
<dl class="docutils">
<dt>parameter_notes: character(len=param_note_length)  <em>pointer</em>  <em>size(:)</em></dt>
<dd>Descriptions of the parameters. The descriptions should be very short indicators such as &#8216;spring constant&#8217; or &#8216;energy coefficient&#8217;. For more detailed explanations, the proper documentation should be used.</dd>
<dt>n_parameters: integer    <em>scalar</em></dt>
<dd>number of parameters</dd>
<dt>description: character(len=pot_note_length)    <em>scalar</em></dt>
<dd>A description of the potential. This should contain the mathematical formulation as well as a short verbal explanation.</dd>
<dt>type_index: integer    <em>scalar</em></dt>
<dd>The internal index of the potential. This can also be used for recognizing the potential and must therefore match the name. For instance, if name = &#8216;LJ&#8217;, type_index = <a class="reference internal" href="#pair_lj_index" title="pair_lj_index"><tt class="xref py py-data docutils literal"><span class="pre">pair_lj_index</span></tt></a>.</dd>
<dt>n_targets: integer    <em>scalar</em></dt>
<dd>number of targets, i.e., interacting bodies</dd>
<dt>parameter_names: character(len=param_name_length)  <em>pointer</em>  <em>size(:)</em></dt>
<dd>The names of the parameters of the potential: these are keywords according to which the parameters may be recognized.</dd>
<dt>name: character(len=pot_name_length)    <em>scalar</em></dt>
<dd>The name of the potential: this is a keyword according to which the potentials may be recognized.</dd>
</dl>
</dd></dl>

</div></blockquote>
</div>
<div class="section" id="full-documentation-of-subroutines-in-potentials">
<h2>Full documentation of subroutines in potentials<a class="headerlink" href="#full-documentation-of-subroutines-in-potentials" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><dl class="function">
<dt id="allocate_ewald_arrays">
<tt class="descname">allocate_ewald_arrays</tt><big>(</big><em>n_atoms</em><big>)</big><a class="headerlink" href="#allocate_ewald_arrays" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameters:</p>
<p>n_atoms: integer  <em>intent(in)</em>    <em>scalar</em></p>
</dd></dl>

<dl class="function">
<dt id="bond_order_factor_affects_atom">
<tt class="descname">bond_order_factor_affects_atom</tt><big>(</big><em>factor</em>, <em>atom_in</em>, <em>affects</em>, <em>position</em><big>)</big><a class="headerlink" href="#bond_order_factor_affects_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether the given bond order factor affects the specific atom.</p>
<p>For bond order factors, the atoms are specified as valid targets by
the atomic symbol only.</p>
<p>If position is not given, then the routine returns true if
the atom can appear in the bond order factor in any role.
If position is given, then true is returned only if the atom
is valid for that particular position.</p>
<p>For instance, we may want to calculate the coordination of
Cu-O bonds for Cu but not for O.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>factor: type(bond_order_parameters)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a></dd>
<dt>atom_in: type(atom)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the <a class="reference internal" href="Geometry_f90.html#atom" title="atom"><tt class="xref py py-data docutils literal"><span class="pre">atom</span></tt></a></dd>
<dt><strong>affects</strong>: logical  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>true if the bond order factor is affected by the atom</dd>
<dt>position: integer  <em>intent(in)</em>    <em>scalar</em>  <em>optional</em></dt>
<dd>specifies the particular role of the atom in the bond order factor</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="bond_order_factor_is_in_group">
<tt class="descname">bond_order_factor_is_in_group</tt><big>(</big><em>factor</em>, <em>group_index</em>, <em>in_group</em><big>)</big><a class="headerlink" href="#bond_order_factor_is_in_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether the given bond order factor is a member of a specific group,
i.e., if it affects the potential specifiesd by the group index.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>factor: type(bond_order_parameters)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a></dd>
<dt>group_index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the index for the potential</dd>
<dt><strong>in_group</strong>: logical  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>true if the factor is a member of the group</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="calculate_derived_parameters_bond_bending">
<tt class="descname">calculate_derived_parameters_bond_bending</tt><big>(</big><em>n_params</em>, <em>parameters</em>, <em>new_potential</em><big>)</big><a class="headerlink" href="#calculate_derived_parameters_bond_bending" title="Permalink to this definition">¶</a></dt>
<dd><p>Bond bending derived parameters</p>
<p>Parameters:</p>
<p>n_params: integer  <em>intent(in)</em>    <em>scalar</em></p>
<p>parameters: double precision  <em>intent(in)</em>    <em>size(n_params)</em></p>
<dl class="docutils">
<dt><strong>new_potential</strong>: type(potential)  <strong>intent(inout)</strong>    <em>scalar</em></dt>
<dd>the potential object for which the parameters are calculated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="calculate_derived_parameters_charge_exp">
<tt class="descname">calculate_derived_parameters_charge_exp</tt><big>(</big><em>n_params</em>, <em>parameters</em>, <em>new_potential</em><big>)</big><a class="headerlink" href="#calculate_derived_parameters_charge_exp" title="Permalink to this definition">¶</a></dt>
<dd><p>Charge exponential derived parameters</p>
<p>Parameters:</p>
<p>n_params: integer  <em>intent(in)</em>    <em>scalar</em></p>
<p>parameters: double precision  <em>intent(in)</em>    <em>size(n_params)</em></p>
<dl class="docutils">
<dt><strong>new_potential</strong>: type(potential)  <strong>intent(inout)</strong>    <em>scalar</em></dt>
<dd>the potential object for which the parameters are calculated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="calculate_derived_parameters_dihedral">
<tt class="descname">calculate_derived_parameters_dihedral</tt><big>(</big><em>n_params</em>, <em>parameters</em>, <em>new_potential</em><big>)</big><a class="headerlink" href="#calculate_derived_parameters_dihedral" title="Permalink to this definition">¶</a></dt>
<dd><p>Dihedral angle derived parameters</p>
<p>Parameters:</p>
<p>n_params: integer  <em>intent(in)</em>    <em>scalar</em></p>
<p>parameters: double precision  <em>intent(in)</em>    <em>size(n_params)</em></p>
<dl class="docutils">
<dt><strong>new_potential</strong>: type(potential)  <strong>intent(inout)</strong>    <em>scalar</em></dt>
<dd>the potential object for which the parameters are calculated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="calculate_ewald_electronegativities">
<tt class="descname">calculate_ewald_electronegativities</tt><big>(</big><em>atoms</em>, <em>cell</em>, <em>real_cutoff</em>, <em>k_radius</em>, <em>reciprocal_cutoff</em>, <em>gaussian_width</em>, <em>electric_constant</em>, <em>scaler</em>, <em>include_dipole_correction</em>, <em>total_enegs</em>, <em>include_realspace</em><big>)</big><a class="headerlink" href="#calculate_ewald_electronegativities" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the electronegativities due to long ranged <span class="math">\(\frac{1}{r}\)</span> potentials.
These electronegativities are the derivatives of the energies <span class="math">\(U\)</span> given by <a class="reference internal" href="#calculate_ewald_energy" title="calculate_ewald_energy"><tt class="xref py py-func docutils literal"><span class="pre">calculate_ewald_energy()</span></tt></a></p>
<div class="math">
\[\chi_\alpha = - \frac{\partial U}{\partial q_\alpha}\]</div>
<p>Parameters:</p>
<dl class="docutils">
<dt>atoms: type(atom)  <em>intent(in)</em>    <em>size(:)</em></dt>
<dd>list of atoms</dd>
<dt>cell: type(supercell)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the supercell containing the system</dd>
<dt>real_cutoff: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>Cutoff radius of real-space interactions. Note that the neighbor lists stored in the atoms are used for neighbor finding so the cutoff cannot exceed the cutoff for the neighbor lists. (Or, it can, but the neighbors not in the lists will not be found.)</dd>
<dt>k_radius: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>Cutoff radius of k-space summation in inverse length. This is an absolute cutoff so that any k-point at a greater distance will be ignored. THis makes the k-cutoff spherical instead of summing over a rectangular box. (It also speeds up the summation.)</dd>
<dt>reciprocal_cutoff: integer  <em>intent(in)</em>    <em>size(3)</em></dt>
<dd>The number of cells to be included in the reciprocal sum in the directions of the reciprocal cell vectors. For example, if <tt class="docutils literal"><span class="pre">reciprocal_cutoff</span> <span class="pre">=</span> <span class="pre">[3,4,5]</span></tt>, the reciprocal sum will be truncated as <span class="math">\(\sum_{\mathbf{k} \ne 0} = \sum_{k_1=-3}^3 \sum_{k_2=-4}^4 \sum_{k_3 = -5,(k_1,k_2,k_3) \ne (0,0,0)}^5\)</span>.</dd>
<dt>gaussian_width: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>The <span class="math">\(\sigma\)</span> parameter, i.e., the distribution width of the screening Gaussians. This should not influence the actual value of the energy, but it does influence the convergence of the summation. If <span class="math">\(\sigma\)</span> is large, the real space sum <span class="math">\(E_s\)</span> converges slowly and a large real space cutoff is needed. If it is small, the reciprocal term <span class="math">\(E_l\)</span> converges slowly and the sum over the reciprocal lattice has to be evaluated over several cell lengths.</dd>
<dt>electric_constant: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>The electic constant, i.e., vacuum permittivity <span class="math">\(\varepsilon_0\)</span>. In atomic units, it is <span class="math">\(\varepsilon_0 = 0.00552635 \frac{e^2}{\mathrm{Å\ eV}}\)</span>, but if one wishes to scale the results to some other unit system (such as reduced units with <span class="math">\(\varepsilon_0 = 1\)</span>), that is possible as well.</dd>
<dt>scaler: double precision  <em>intent(in)</em>    <em>size(:)</em></dt>
<dd>a list of numerical values to scale the individual charges of the atoms</dd>
<dt>include_dipole_correction: logical  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>if true, a dipole correction term is included</dd>
<dt><strong>total_enegs</strong>: double precision  <strong>intent(inout)</strong>    <em>size(:)</em></dt>
<dd>the calculated electronegativities</dd>
<dt>include_realspace: logical  <em>intent(in)</em>    <em>scalar</em>  <em>optional</em></dt>
<dd>By default, also the real space summation is carried out, but giving the .false. flag here will prevent the calculation. This is used in the normal evaluation loop where the real space sum is calculated during the evaluation of other pairwise interactions.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="calculate_ewald_energy">
<tt class="descname">calculate_ewald_energy</tt><big>(</big><em>atoms</em>, <em>cell</em>, <em>real_cutoff</em>, <em>k_radius</em>, <em>reciprocal_cutoff</em>, <em>gaussian_width</em>, <em>electric_constant</em>, <em>scaler</em>, <em>include_dipole_correction</em>, <em>total_energy</em>, <em>include_realspace</em><big>)</big><a class="headerlink" href="#calculate_ewald_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the energy of <span class="math">\(\frac{1}{r}\)</span> potentials through Ewald summation.</p>
<p>If a periodic system contains charges interacting via the <span class="math">\(\frac{1}{r}\)</span> Coulomb potential,
direct summation of the interactions</p>
<div class="math" id="equation-direct_sum">
<span class="eqno">(1)</span>\[E = \sum_{(i,j)} \frac{1}{4\pi\epsilon_0}\frac{q_i q_j}{r_{ij}},\]</div>
<p>where the sum is over pairs of charges <span class="math">\(q_i, q_j\)</span>
(charges of the entire system, not just the simulation cell) and the distance between the charges is
<span class="math">\(r_{ij} = |\mathbf{r}_j - \mathbf{r}_i|\)</span>,
does not work in general because the sum <a href="#equation-direct_sum">(1)</a> converges very slowly. <a class="footnote-reference" href="#id2" id="id1">[1]</a> Therefore truncating the
sum may lead to severe errors.</p>
<p>The standard technique for overcoming this problem is the so called Ewald summation method.
The idea is to split the long ranged and singular Coulomb potential to a short ranged singular and
long ranged smooth parts, and calculate the long ranged part in reciprocal space via Fourier transformations.
This is possible since the system is periodic and the same supercell repeats infinitely in all directions.
In practice the calculation can be done by adding (and subtracting) Gaussian charge densities over the
point charges to screen the
potential in real space. That is, the original charge density
<span class="math">\(\rho(\mathbf{r}) = \sum_i q_i \delta(\mathbf{r} - \mathbf{r}_i)\)</span> is split by</p>
<div class="math">
\[\begin{eqnarray}
\rho(\mathbf{r}) & = & \rho_s(\mathbf{r}) + \rho_l(\mathbf{r}) \\
\rho_s(\mathbf{r}) & = & \sum_i \left[ q_i \delta(\mathbf{r} - \mathbf{r}_i) - q_i G_\sigma(\mathbf{r} - \mathbf{r}_i) \right] \\
\rho_l(\mathbf{r}) & = & \sum_i q_i G_\sigma(\mathbf{r} - \mathbf{r}_i) \\
G_\sigma(\mathbf{r}) & = & \frac{1}{(2 \pi \sigma^2)^{3/2}} \exp\left( -\frac{|\mathbf{r}|^2}{2 \sigma^2} \right)
\end{eqnarray}\]</div><p>Here <span class="math">\(\rho_l\)</span> generates a long range interaction since at large distances the Gaussian densities
<span class="math">\(G_\sigma\)</span> appear the same as point charges
(<span class="math">\(\lim_{\sigma/r \to 0} G_\sigma(\mathbf{r}) = \delta(\mathbf{r})\)</span>).
Since the charge density is smooth, so will be the potential it creates.
The density <span class="math">\(\rho_s\)</span> exhibits short ranged interactions for the same reason:
At distances longer than the width of the
Gaussians the point charges are screened by the Gaussians which exactly cancel them
(<span class="math">\(\lim_{\sigma/r \to 0} \delta(\mathbf{r}) - G_\sigma(\mathbf{r}) = 0\)</span>).</p>
<p>The short ranged interactions are directly calculated in real space</p>
<div class="math">
\[\begin{eqnarray}
E_s & = & \frac{1}{4 \pi \varepsilon_0} \int \frac{\rho_s(\mathbf{r}) \rho_s(\mathbf{r}')}{|\mathbf{r} - \mathbf{r}'|} \mathrm{d}^3 r \mathrm{d}^3 r' \\
    & = & \frac{1}{4 \pi \varepsilon_0} \sum_{(i,j)} \frac{q_i q_j}{r_{ij}} \mathrm{erfc} \left( \frac{r_{ij}}{\sigma \sqrt{2}} \right).
\end{eqnarray}\]</div><p>The complementary error function <span class="math">\(\mathrm{erfc}(r) = 1 - \mathrm{erf}(r) = 1 - \frac{2}{\sqrt{\pi}} \int_0^r e^{-t^2/2} \mathrm{d}t\)</span> makes the sum converge rapidly as <span class="math">\(\frac{r_{ij}}{\sigma} \to \infty\)</span>.</p>
<p>The long ranged interaction can be calculated in reciprocal space by Fourier transformation. The result is</p>
<div class="math">
\[\begin{eqnarray}
E_l & = & \frac{1}{2 V \varepsilon_0} \sum_{\mathbf{k} \ne 0} \frac{e^{-\sigma^2 k^2 / 2}}{k^2} |S(\mathbf{k})|^2 - \frac{1}{4 \pi \varepsilon_0} \frac{1}{\sqrt{2 \pi} \sigma} \sum_i^N q_i^2\\
S(\mathbf{k}) & = & \sum_i^N q_i e^{\mathrm{i} \mathbf{k} \cdot \mathbf{r}_i}
\end{eqnarray}\]</div><p>The first sum in <span class="math">\(E_l\)</span> runs over the reciprocal lattice
<span class="math">\(\mathbf{k} = k_1 \mathbf{b}_1 + k_2 \mathbf{b}_2 + k_3 \mathbf{b}_3\)</span> where <span class="math">\(\mathbf{b}_i\)</span>
are the vectors spanning the reciprocal cell (<span class="math">\([\mathbf{b}_1 \mathbf{b}_2 \mathbf{b}_3] = ([\mathbf{v}_1 \mathbf{v}_2 \mathbf{v}_3]^{-1})^T\)</span> where <span class="math">\(\mathbf{v}_i\)</span> are the real space cell vectors).
The latter sum is the self energy of each point charge in the potential of the particular Gaussian that
screens the charge, and the sum runs
over all charges in the supercell spanning the periodic system.
(The self energy must be removed because it is present in the first sum even though when evaluating
the potential at the position of a charge
due to the other charges, no screening Gaussian function should be placed over the charge itself.)
Likewise the sum in the structure factor <span class="math">\(S(\mathbf{k})\)</span> runs over all charges in the supercell.</p>
<p>The total energy is then the sum of the short and long range energies</p>
<div class="math">
\[E = E_s + E_l.\]</div>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>In fact, the sum converges only conditionally meaning the result depends on the order of summation. Physically this is not a problem, because one never has infinite lattices.</td></tr>
</tbody>
</table>
<p>Parameters:</p>
<dl class="docutils">
<dt>atoms: type(atom)  <em>intent(in)</em>    <em>size(:)</em></dt>
<dd>list of atoms</dd>
<dt>cell: type(supercell)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the supercell containing the system</dd>
<dt>real_cutoff: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>Cutoff radius of real-space interactions. Note that the neighbor lists stored in the atoms are used for neighbor finding so the cutoff cannot exceed the cutoff for the neighbor lists. (Or, it can, but the neighbors not in the lists will not be found.)</dd>
<dt>k_radius: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>absolute k-space cutoff</dd>
<dt>reciprocal_cutoff: integer  <em>intent(in)</em>    <em>size(3)</em></dt>
<dd>The number of cells to be included in the reciprocal sum in the directions of the reciprocal cell vectors. For example, if <tt class="docutils literal"><span class="pre">reciprocal_cutoff</span> <span class="pre">=</span> <span class="pre">[3,4,5]</span></tt>, the reciprocal sum will be truncated as <span class="math">\(\sum_{\mathbf{k} \ne 0} = \sum_{k_1=-3}^3 \sum_{k_2=-4}^4 \sum_{k_3 = -5,(k_1,k_2,k_3) \ne (0,0,0)}^5\)</span>.</dd>
<dt>gaussian_width: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>The <span class="math">\(\sigma\)</span> parameter, i.e., the distribution width of the screening Gaussians. This should not influence the actual value of the energy, but it does influence the convergence of the summation. If <span class="math">\(\sigma\)</span> is large, the real space sum <span class="math">\(E_s\)</span> converges slowly and a large real space cutoff is needed. If it is small, the reciprocal term <span class="math">\(E_l\)</span> converges slowly and the sum over the reciprocal lattice has to be evaluated over several cell lengths.</dd>
<dt>electric_constant: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>The electic constant, i.e., vacuum permittivity <span class="math">\(\varepsilon_0\)</span>. In atomic units, it is <span class="math">\(\varepsilon_0 = 0.00552635 \frac{e^2}{\mathrm{Å\ eV}}\)</span>, but if one wishes to scale the results to some other unit system (such as reduced units with <span class="math">\(\varepsilon_0 = 1\)</span>), that is possible as well.</dd>
<dt>scaler: double precision  <em>intent(in)</em>    <em>size(:)</em></dt>
<dd>a list of numerical values to scale the individual charges of the atoms</dd>
<dt>include_dipole_correction: logical  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>if true, a dipole correction term is included in the energy</dd>
<dt><strong>total_energy</strong>: double precision  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the calculated energy</dd>
<dt>include_realspace: logical  <em>intent(in)</em>    <em>scalar</em>  <em>optional</em></dt>
<dd>By default, also the real space summation is carried out, but giving the .false. flag here will prevent the calculation. This is used in the normal evaluation loop where the real space sum is calculated during the evaluation of other pairwise interactions.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="calculate_ewald_forces">
<tt class="descname">calculate_ewald_forces</tt><big>(</big><em>atoms</em>, <em>cell</em>, <em>real_cutoff</em>, <em>k_radius</em>, <em>reciprocal_cutoff</em>, <em>gaussian_width</em>, <em>electric_constant</em>, <em>scaler</em>, <em>include_dipole_correction</em>, <em>total_forces</em>, <em>total_stress</em>, <em>include_realspace</em><big>)</big><a class="headerlink" href="#calculate_ewald_forces" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the forces due to long ranged <span class="math">\(\frac{1}{r}\)</span> potentials.
These forces are the gradients of the energies <span class="math">\(U\)</span> given by <a class="reference internal" href="#calculate_ewald_energy" title="calculate_ewald_energy"><tt class="xref py py-func docutils literal"><span class="pre">calculate_ewald_energy()</span></tt></a></p>
<div class="math">
\[\mathbf{F}_\alpha = - \nabla_\alpha U\]</div>
<p>Parameters:</p>
<dl class="docutils">
<dt>atoms: type(atom)  <em>intent(in)</em>    <em>size(:)</em></dt>
<dd>list of atoms</dd>
<dt>cell: type(supercell)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the supercell containing the system</dd>
<dt>real_cutoff: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>Cutoff radius of real-space interactions. Note that the neighbor lists stored in the atoms are used for neighbor finding so the cutoff cannot exceed the cutoff for the neighbor lists. (Or, it can, but the neighbors not in the lists will not be found.)</dd>
<dt>k_radius: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>Cutoff radius of k-space summation in inverse length. This is an absolute cutoff so that any k-point at a greater distance will be ignored. THis makes the k-cutoff spherical instead of summing over a rectangular box. (It also speeds up the summation.)</dd>
<dt>reciprocal_cutoff: integer  <em>intent(in)</em>    <em>size(3)</em></dt>
<dd>The number of cells to be included in the reciprocal sum in the directions of the reciprocal cell vectors. For example, if <tt class="docutils literal"><span class="pre">reciprocal_cutoff</span> <span class="pre">=</span> <span class="pre">[3,4,5]</span></tt>, the reciprocal sum will be truncated as <span class="math">\(\sum_{\mathbf{k} \ne 0} = \sum_{k_1=-3}^3 \sum_{k_2=-4}^4 \sum_{k_3 = -5,(k_1,k_2,k_3) \ne (0,0,0)}^5\)</span>.</dd>
<dt>gaussian_width: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>The <span class="math">\(\sigma\)</span> parameter, i.e., the distribution width of the screening Gaussians. This should not influence the actual value of the energy, but it does influence the convergence of the summation. If <span class="math">\(\sigma\)</span> is large, the real space sum <span class="math">\(E_s\)</span> converges slowly and a large real space cutoff is needed. If it is small, the reciprocal term <span class="math">\(E_l\)</span> converges slowly and the sum over the reciprocal lattice has to be evaluated over several cell lengths.</dd>
<dt>electric_constant: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>The electic constant, i.e., vacuum permittivity <span class="math">\(\varepsilon_0\)</span>. In atomic units, it is <span class="math">\(\varepsilon_0 = 0.00552635 \frac{e^2}{\mathrm{Å\ eV}}\)</span>, but if one wishes to scale the results to some other unit system (such as reduced units with <span class="math">\(\varepsilon_0 = 1\)</span>), that is possible as well.</dd>
<dt>scaler: double precision  <em>intent(in)</em>    <em>size(:)</em></dt>
<dd>a list of numerical values to scale the individual charges of the atoms</dd>
<dt>include_dipole_correction: logical  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>if true, a dipole correction term is included in the energy</dd>
<dt><strong>total_forces</strong>: double precision  <strong>intent(inout)</strong>    <em>size(:, :)</em></dt>
<dd>the calculated forces</dd>
<dt><strong>total_stress</strong>: double precision  <strong>intent(inout)</strong>    <em>size(6)</em></dt>
<dd>the calculated stress</dd>
<dt>include_realspace: logical  <em>intent(in)</em>    <em>scalar</em>  <em>optional</em></dt>
<dd>By default, also the real space summation is carried out, but giving the .false. flag here will prevent the calculation. This is used in the normal evaluation loop where the real space sum is calculated during the evaluation of other pairwise interactions.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="check_s_factor_array_allocation">
<tt class="descname">check_s_factor_array_allocation</tt><big>(</big><em>n_atoms</em>, <em>reciprocal_cutoff</em><big>)</big><a class="headerlink" href="#check_s_factor_array_allocation" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameters:</p>
<p>n_atoms: integer  <em>intent(in)</em>    <em>scalar</em></p>
<p>reciprocal_cutoff: integer  <em>intent(in)</em>    <em>size(3)</em></p>
</dd></dl>

<dl class="function">
<dt id="clear_bond_order_factor_characterizers">
<tt class="descname">clear_bond_order_factor_characterizers</tt><big>(</big><big>)</big><a class="headerlink" href="#clear_bond_order_factor_characterizers" title="Permalink to this definition">¶</a></dt>
<dd><p>Deallocates all memory associated with bond order factor characterizes.</p>
</dd></dl>

<dl class="function">
<dt id="clear_potential_characterizers">
<tt class="descname">clear_potential_characterizers</tt><big>(</big><big>)</big><a class="headerlink" href="#clear_potential_characterizers" title="Permalink to this definition">¶</a></dt>
<dd><p>Deallocates all memory associated with potential characterizes.</p>
</dd></dl>

<dl class="function">
<dt id="create_bond_order_factor">
<tt class="descname">create_bond_order_factor</tt><big>(</big><em>n_targets</em>, <em>n_params</em>, <em>n_split</em>, <em>bond_name</em>, <em>parameters</em>, <em>param_split</em>, <em>cutoff</em>, <em>soft_cutoff</em>, <em>elements</em>, <em>orig_elements</em>, <em>group_index</em>, <em>new_bond</em>, <em>success</em><big>)</big><a class="headerlink" href="#create_bond_order_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a>.</p>
<p>The routine takes as arguments all the necessary parameters
and returns a bond order parameters type wrapping them in one package.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_targets: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of targets, i.e., interacting bodies</dd>
<dt>n_params: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>array containing the numbers of parameters for different number of targets (1-body parameters, 2-body parameters, etc.)</dd>
<dt>n_split: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of groupings in the list of parameters, per number of bodies - should equal n_targets</dd>
<dt>bond_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the bond order factor - a keyword that must match a name of one of the <a class="reference internal" href="#bond_order_descriptors" title="bond_order_descriptors"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_descriptors</span></tt></a></dd>
<dt>parameters: double precision  <em>intent(in)</em>    <em>size(n_params)</em></dt>
<dd>numerical values for parameters as a one-dimensional array</dd>
<dt>param_split: integer  <em>intent(in)</em>    <em>size(n_split)</em></dt>
<dd>Array containing the numbers of 1-body, 2-body, etc. parameters. The parameters are given as a list, but a bond order factor may have parameters separately for different numbers of targets. This list specifies the number of parameters for each.</dd>
<dt>cutoff: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>The hard cutoff for the bond order factor. If the atoms are farther away from each other than this, they do not contribute to the total bond order factor does not affect them.</dd>
<dt>soft_cutoff: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>The soft cutoff for the bond order factor. If this is smaller than the hard cutoff, the bond contribution is scaled to zero continuously when the interatomic distances grow from the soft to the hard cutoff.</dd>
<dt>elements: character(len=2)  <em>intent(in)</em>    <em>size(n_targets)</em></dt>
<dd>a list of elements (atomic symbols) the factor affects</dd>
<dt>orig_elements: character(len=2)  <em>intent(in)</em>    <em>size(n_targets)</em></dt>
<dd>the list of elements (atomic symbols) of the original <tt class="xref py py-class docutils literal"><span class="pre">BondOrderParameters</span></tt> in the Python interface from which this factor was created</dd>
<dt>group_index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>The internal index of the <em>potential</em> the bond order factor is modifying.</dd>
<dt><strong>new_bond</strong>: type(bond_order_parameters)  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the created <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a></dd>
<dt><strong>success</strong>: logical  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>logical tag specifying if creation of the factor succeeded</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="create_bond_order_factor_characterizer_coordination">
<tt class="descname">create_bond_order_factor_characterizer_coordination</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#create_bond_order_factor_characterizer_coordination" title="Permalink to this definition">¶</a></dt>
<dd><p>Coordination characterizer initialization</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index of the bond order factor</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="create_bond_order_factor_characterizer_power">
<tt class="descname">create_bond_order_factor_characterizer_power</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#create_bond_order_factor_characterizer_power" title="Permalink to this definition">¶</a></dt>
<dd><p>Power decay characterizer initialization</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index of the bond order factor</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="create_bond_order_factor_characterizer_scaler_1">
<tt class="descname">create_bond_order_factor_characterizer_scaler_1</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#create_bond_order_factor_characterizer_scaler_1" title="Permalink to this definition">¶</a></dt>
<dd><p>Scaler characterizer initialization</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index of the bond order factor</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="create_bond_order_factor_characterizer_scaler_sqrt">
<tt class="descname">create_bond_order_factor_characterizer_scaler_sqrt</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#create_bond_order_factor_characterizer_scaler_sqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Square root scaler characterizer initialization</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index of the bond order factor</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="create_bond_order_factor_characterizer_scaler_table">
<tt class="descname">create_bond_order_factor_characterizer_scaler_table</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#create_bond_order_factor_characterizer_scaler_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Square root scaler characterizer initialization</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index of the bond order factor</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="create_bond_order_factor_characterizer_table">
<tt class="descname">create_bond_order_factor_characterizer_table</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#create_bond_order_factor_characterizer_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Tabulated characterizer initialization</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index of the bond order factor</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="create_bond_order_factor_characterizer_tersoff">
<tt class="descname">create_bond_order_factor_characterizer_tersoff</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#create_bond_order_factor_characterizer_tersoff" title="Permalink to this definition">¶</a></dt>
<dd><p>Tersoff characterizer initialization</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index of the bond order factor</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="create_bond_order_factor_characterizer_triplet">
<tt class="descname">create_bond_order_factor_characterizer_triplet</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#create_bond_order_factor_characterizer_triplet" title="Permalink to this definition">¶</a></dt>
<dd><p>Triplet characterizer initialization</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index of the bond order factor</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="create_potential">
<tt class="descname">create_potential</tt><big>(</big><em>n_targets</em>, <em>n_params</em>, <em>pot_name</em>, <em>parameters</em>, <em>cutoff</em>, <em>soft_cutoff</em>, <em>elements</em>, <em>tags</em>, <em>indices</em>, <em>orig_elements</em>, <em>orig_tags</em>, <em>orig_indices</em>, <em>pot_index</em>, <em>n_multi</em>, <em>multipliers</em>, <em>new_potential</em>, <em>success</em><big>)</big><a class="headerlink" href="#create_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a>.</p>
<p>The routine takes as arguments all the necessary parameters
and returns a potential type wrapping them in one package.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_targets: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of targets, i.e., interacting bodies</dd>
<dt>n_params: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of parameters</dd>
<dt>pot_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the potential - a keyword that must match a name of one of the <a class="reference internal" href="#potential_descriptors" title="potential_descriptors"><tt class="xref py py-data docutils literal"><span class="pre">potential_descriptors</span></tt></a></dd>
<dt>parameters: double precision  <em>intent(in)</em>    <em>size(n_params)</em></dt>
<dd>array of numerical values for the parameters</dd>
<dt>cutoff: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the hard cutoff for the potential</dd>
<dt>soft_cutoff: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the soft cutoff for the potential</dd>
<dt>elements: character(len=2)  <em>intent(in)</em>    <em>size(n_targets)</em></dt>
<dd>the elements (atomic symbols) the potential acts on</dd>
<dt>tags: integer  <em>intent(in)</em>    <em>size(n_targets)</em></dt>
<dd>the atom tags the potential acts on</dd>
<dt>indices: integer  <em>intent(in)</em>    <em>size(n_targets)</em></dt>
<dd>the atom indices the potential acts on</dd>
<dt>orig_elements: character(len=2)  <em>intent(in)</em>    <em>size(n_targets)</em></dt>
<dd>The elements (atomic symbols) in the <tt class="xref py py-class docutils literal"><span class="pre">Potential</span></tt> used for generating the potential. This is needed to specify the roles of the atoms in the interaction.</dd>
<dt>orig_tags: integer  <em>intent(in)</em>    <em>size(n_targets)</em></dt>
<dd>The atom tags in the <tt class="xref py py-class docutils literal"><span class="pre">Potential</span></tt> used for generating the potential. This is needed to specify the roles of the atoms in the interaction.</dd>
<dt>orig_indices: integer  <em>intent(in)</em>    <em>size(n_targets)</em></dt>
<dd>The atom indices in the <tt class="xref py py-class docutils literal"><span class="pre">Potential</span></tt> used for generating the potential. This is needed to specify the roles of the atoms in the interaction.</dd>
<dt>pot_index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the internal index of the potential</dd>
<dt>n_multi: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of multiplying potentials</dd>
<dt>multipliers: type(potential)  <em>intent(in)</em>    <em>size(n_multi)</em></dt>
<dd>the multiplying potentials</dd>
<dt><strong>new_potential</strong>: type(potential)  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the created <a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a></dd>
<dt><strong>success</strong>: logical  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>logical tag specifying if creation of the potential succeeded</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="create_potential_characterizer_LJ">
<tt class="descname">create_potential_characterizer_LJ</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#create_potential_characterizer_LJ" title="Permalink to this definition">¶</a></dt>
<dd><p>LJ characterizer initialization</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index of the potential</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="create_potential_characterizer_bond_bending">
<tt class="descname">create_potential_characterizer_bond_bending</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#create_potential_characterizer_bond_bending" title="Permalink to this definition">¶</a></dt>
<dd><p>bond-bending characterizer initialization</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index of the potential</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="create_potential_characterizer_buckingham">
<tt class="descname">create_potential_characterizer_buckingham</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#create_potential_characterizer_buckingham" title="Permalink to this definition">¶</a></dt>
<dd><p>Buckingham characterizer initialization</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index of the potential</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="create_potential_characterizer_charge_exp">
<tt class="descname">create_potential_characterizer_charge_exp</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#create_potential_characterizer_charge_exp" title="Permalink to this definition">¶</a></dt>
<dd><p>charge exponential characterizer initialization</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index of the potential</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="create_potential_characterizer_charge_pair">
<tt class="descname">create_potential_characterizer_charge_pair</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#create_potential_characterizer_charge_pair" title="Permalink to this definition">¶</a></dt>
<dd><p>charge self energy characterizer initialization</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index of the potential</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="create_potential_characterizer_charge_pair_abs">
<tt class="descname">create_potential_characterizer_charge_pair_abs</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#create_potential_characterizer_charge_pair_abs" title="Permalink to this definition">¶</a></dt>
<dd><p>charge abs energy characterizer initialization</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index of the potential</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="create_potential_characterizer_charge_self">
<tt class="descname">create_potential_characterizer_charge_self</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#create_potential_characterizer_charge_self" title="Permalink to this definition">¶</a></dt>
<dd><p>charge self energy characterizer initialization</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index of the potential</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="create_potential_characterizer_constant_force">
<tt class="descname">create_potential_characterizer_constant_force</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#create_potential_characterizer_constant_force" title="Permalink to this definition">¶</a></dt>
<dd><p>constant F characterizer initialization</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index of the potential</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="create_potential_characterizer_constant_potential">
<tt class="descname">create_potential_characterizer_constant_potential</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#create_potential_characterizer_constant_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>constant potential characterizer initialization</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index of the potential</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="create_potential_characterizer_dihedral">
<tt class="descname">create_potential_characterizer_dihedral</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#create_potential_characterizer_dihedral" title="Permalink to this definition">¶</a></dt>
<dd><p>dihedral angle characterizer initialization</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index of the potential</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="create_potential_characterizer_exp">
<tt class="descname">create_potential_characterizer_exp</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#create_potential_characterizer_exp" title="Permalink to this definition">¶</a></dt>
<dd><p>exponential characterizer initialization</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index of the potential</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="create_potential_characterizer_power">
<tt class="descname">create_potential_characterizer_power</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#create_potential_characterizer_power" title="Permalink to this definition">¶</a></dt>
<dd><p>Power law characterizer initialization</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index of the potential</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="create_potential_characterizer_shift">
<tt class="descname">create_potential_characterizer_shift</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#create_potential_characterizer_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift characterizer initialization</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index of the potential</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="create_potential_characterizer_spring">
<tt class="descname">create_potential_characterizer_spring</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#create_potential_characterizer_spring" title="Permalink to this definition">¶</a></dt>
<dd><p>spring characterizer initialization</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index of the potential</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="create_potential_characterizer_step">
<tt class="descname">create_potential_characterizer_step</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#create_potential_characterizer_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Step characterizer initialization</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index of the potential</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="create_potential_characterizer_table">
<tt class="descname">create_potential_characterizer_table</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#create_potential_characterizer_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Tabulated characterizer initialization</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index of the potential</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="deallocate_ewald_arrays">
<tt class="descname">deallocate_ewald_arrays</tt><big>(</big><big>)</big><a class="headerlink" href="#deallocate_ewald_arrays" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="evaluate_bond_order_factor">
<tt class="descname">evaluate_bond_order_factor</tt><big>(</big><em>n_targets</em>, <em>separations</em>, <em>distances</em>, <em>bond_params</em>, <em>factor</em>, <em>atoms</em><big>)</big><a class="headerlink" href="#evaluate_bond_order_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a bond order factor term.</p>
<p>By a bond order factor term, we mean the contribution from
specific atoms, <span class="math">\(c_{ijk}\)</span>, appearing in the factor</p>
<div class="math">
\[b_i = f(\sum_{jk} c_{ijk})\]</div>
<p>This routine evaluates the term <span class="math">\(c_{ij}\)</span> or <span class="math">\(c_{ijk}\)</span> for the given
atoms <span class="math">\(ij\)</span> or <span class="math">\(ijk\)</span> according to the given parameters.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_targets: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of targets</dd>
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, n_targets-1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathbf{r}_{12}\)</span>, <span class="math">\(\mathbf{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(n_targets-1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>bond_params: type(bond_order_parameters)  <em>intent(in)</em>    <em>size(n_targets-1)</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>factor</strong>: double precision  <strong>intent(out)</strong>    <em>size(n_targets)</em></dt>
<dd>the calculated bond order term <span class="math">\(c\)</span></dd>
<dt>atoms: type(atom)  <em>intent(in)</em>    <em>size(n_targets)</em></dt>
<dd>a list of the actual <a class="reference internal" href="Geometry_f90.html#atom" title="atom"><tt class="xref py py-data docutils literal"><span class="pre">atom</span></tt></a> objects for which the term is calculated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_bond_order_factor_coordination">
<tt class="descname">evaluate_bond_order_factor_coordination</tt><big>(</big><em>separations</em>, <em>distances</em>, <em>bond_params</em>, <em>factor</em><big>)</big><a class="headerlink" href="#evaluate_bond_order_factor_coordination" title="Permalink to this definition">¶</a></dt>
<dd><p>Coordination bond order factor</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, 1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathbf{r}_{12}\)</span>, <span class="math">\(\mathbf{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>bond_params: type(bond_order_parameters)  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>factor</strong>: double precision  <strong>intent(out)</strong>    <em>size(2)</em></dt>
<dd>the calculated bond order term <span class="math">\(c\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_bond_order_factor_power">
<tt class="descname">evaluate_bond_order_factor_power</tt><big>(</big><em>separations</em>, <em>distances</em>, <em>bond_params</em>, <em>factor</em><big>)</big><a class="headerlink" href="#evaluate_bond_order_factor_power" title="Permalink to this definition">¶</a></dt>
<dd><p>Power bond order factor</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, 1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathbf{r}_{12}\)</span>, <span class="math">\(\mathbf{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>bond_params: type(bond_order_parameters)  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>factor</strong>: double precision  <strong>intent(out)</strong>    <em>size(2)</em></dt>
<dd>the calculated bond order term <span class="math">\(c\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_bond_order_factor_table">
<tt class="descname">evaluate_bond_order_factor_table</tt><big>(</big><em>separations</em>, <em>distances</em>, <em>bond_params</em>, <em>factor</em><big>)</big><a class="headerlink" href="#evaluate_bond_order_factor_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Tabulated bond order factor</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, 1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathbf{r}_{12}\)</span>, <span class="math">\(\mathbf{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>bond_params: type(bond_order_parameters)  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>factor</strong>: double precision  <strong>intent(out)</strong>    <em>size(2)</em></dt>
<dd>the calculated bond order term <span class="math">\(c\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_bond_order_factor_triplet">
<tt class="descname">evaluate_bond_order_factor_triplet</tt><big>(</big><em>separations</em>, <em>distances</em>, <em>bond_params</em>, <em>factor</em>, <em>atoms</em><big>)</big><a class="headerlink" href="#evaluate_bond_order_factor_triplet" title="Permalink to this definition">¶</a></dt>
<dd><p>Triplet bond factor</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, 2)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathbf{r}_{12}\)</span>, <span class="math">\(\mathbf{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(2)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>bond_params: type(bond_order_parameters)  <em>intent(in)</em>    <em>size(2)</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>factor</strong>: double precision  <strong>intent(out)</strong>    <em>size(3)</em></dt>
<dd>the calculated bond order term <span class="math">\(c\)</span></dd>
<dt>atoms: type(atom)  <em>intent(in)</em>    <em>size(3)</em></dt>
<dd>a list of the actual <a class="reference internal" href="Geometry_f90.html#atom" title="atom"><tt class="xref py py-data docutils literal"><span class="pre">atom</span></tt></a> objects for which the term is calculated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_bond_order_gradient">
<tt class="descname">evaluate_bond_order_gradient</tt><big>(</big><em>n_targets</em>, <em>separations</em>, <em>distances</em>, <em>bond_params</em>, <em>gradient</em>, <em>atoms</em><big>)</big><a class="headerlink" href="#evaluate_bond_order_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the gradients of bond order terms with respect to moving an atom.</p>
<p>By a bond order factor term, we mean the contribution from
specific atoms, c_ijk, appearing in the factor</p>
<div class="math">
\[b_i = f(\sum_{jk} c_{ijk})\]</div>
<p>This routine evaluates the gradient term <span class="math">\(\nabla_\alpha c_{ij}\)</span> or
<span class="math">\(\nabla_\alpha c_{ijk}\)</span> for the given atoms <span class="math">\(ij\)</span> or <span class="math">\(ijk\)</span> according to the given parameters.</p>
<p>The returned array has three dimensions:
gradient( coordinates, atom whose factor is differentiated, atom with respect to which we differentiate )
So for example, for a three body term atom1-atom2-atom3, gradient(1,2,3) contains
the x-coordinate (1), of the factor for atom2 (2), with respect to moving atom3 (3).</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_targets: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of targets</dd>
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, n_targets-1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathrm{r}_{12}\)</span>, <span class="math">\(\mathrm{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(n_targets-1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>bond_params: type(bond_order_parameters)  <em>intent(in)</em>    <em>size(n_targets-1)</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>gradient</strong>: double precision  <strong>intent(out)</strong>    <em>size(3, n_targets, n_targets)</em></dt>
<dd>the calculated bond order term <span class="math">\(\nabla_\alpha c\)</span></dd>
<dt>atoms: type(atom)  <em>intent(in)</em>    <em>size(n_targets)</em></dt>
<dd>a list of the actual <a class="reference internal" href="Geometry_f90.html#atom" title="atom"><tt class="xref py py-data docutils literal"><span class="pre">atom</span></tt></a> objects for which the term is calculated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_bond_order_gradient_coordination">
<tt class="descname">evaluate_bond_order_gradient_coordination</tt><big>(</big><em>separations</em>, <em>distances</em>, <em>bond_params</em>, <em>gradient</em><big>)</big><a class="headerlink" href="#evaluate_bond_order_gradient_coordination" title="Permalink to this definition">¶</a></dt>
<dd><p>Coordination bond order factor gradient</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, 1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathbf{r}_{12}\)</span>, <span class="math">\(\mathbf{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>bond_params: type(bond_order_parameters)  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>gradient</strong>: double precision  <strong>intent(out)</strong>    <em>size(3, 2, 2)</em></dt>
<dd>the calculated bond order term <span class="math">\(c\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_bond_order_gradient_power">
<tt class="descname">evaluate_bond_order_gradient_power</tt><big>(</big><em>separations</em>, <em>distances</em>, <em>bond_params</em>, <em>gradient</em><big>)</big><a class="headerlink" href="#evaluate_bond_order_gradient_power" title="Permalink to this definition">¶</a></dt>
<dd><p>Power bond order factor gradient</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, 1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathbf{r}_{12}\)</span>, <span class="math">\(\mathbf{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>bond_params: type(bond_order_parameters)  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>gradient</strong>: double precision  <strong>intent(out)</strong>    <em>size(3, 2, 2)</em></dt>
<dd>the calculated bond order term <span class="math">\(c\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_bond_order_gradient_table">
<tt class="descname">evaluate_bond_order_gradient_table</tt><big>(</big><em>separations</em>, <em>distances</em>, <em>bond_params</em>, <em>gradient</em><big>)</big><a class="headerlink" href="#evaluate_bond_order_gradient_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Tabulated bond order factor gradient</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, 1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathbf{r}_{12}\)</span>, <span class="math">\(\mathbf{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>bond_params: type(bond_order_parameters)  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>gradient</strong>: double precision  <strong>intent(out)</strong>    <em>size(3, 2, 2)</em></dt>
<dd>the calculated bond order term <span class="math">\(c\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_bond_order_gradient_triplet">
<tt class="descname">evaluate_bond_order_gradient_triplet</tt><big>(</big><em>separations</em>, <em>distances</em>, <em>bond_params</em>, <em>gradient</em>, <em>atoms</em><big>)</big><a class="headerlink" href="#evaluate_bond_order_gradient_triplet" title="Permalink to this definition">¶</a></dt>
<dd><p>Coordination bond order factor gradient</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, 2)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathbf{r}_{12}\)</span>, <span class="math">\(\mathbf{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(2)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>bond_params: type(bond_order_parameters)  <em>intent(in)</em>    <em>size(2)</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>gradient</strong>: double precision  <strong>intent(out)</strong>    <em>size(3, 3, 3)</em></dt>
<dd>the calculated bond order term <span class="math">\(c\)</span></dd>
<dt>atoms: type(atom)  <em>intent(in)</em>    <em>size(3)</em></dt>
<dd>a list of the actual <a class="reference internal" href="Geometry_f90.html#atom" title="atom"><tt class="xref py py-data docutils literal"><span class="pre">atom</span></tt></a> objects for which the term is calculated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_electronegativity">
<tt class="descname">evaluate_electronegativity</tt><big>(</big><em>n_targets</em>, <em>n_product</em>, <em>separations</em>, <em>distances</em>, <em>interaction</em>, <em>eneg</em>, <em>atoms</em><big>)</big><a class="headerlink" href="#evaluate_electronegativity" title="Permalink to this definition">¶</a></dt>
<dd><p>If a potential, say, <span class="math">\(U_{ijk}\)</span> depends on the charges of atoms <span class="math">\(q_i\)</span>
it will not only create a force,
but also a difference in chemical potential <span class="math">\(\mu_i\)</span> for the atomic partial charges.
Similarly to <a class="reference internal" href="#evaluate_forces" title="evaluate_forces"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_forces()</span></tt></a>, this function evaluates the chemical
&#8216;force&#8217; on the atomic charges</p>
<div class="math">
\[\chi_{\alpha,ijk} = -\mu_{\alpha,ijk} = -\frac{\partial U_{ijk}}{\partial q_\alpha}\]</div>
<p>This routine can evaluate the contribution from a product potential.</p>
<p>To be consist the forces returned by <a class="reference internal" href="#evaluate_electronegativity" title="evaluate_electronegativity"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_electronegativity()</span></tt></a> must be
derivatives of the energies returned by <a class="reference internal" href="#evaluate_energy" title="evaluate_energy"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_energy()</span></tt></a>.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_targets: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of targets</dd>
<dt>n_product: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the number of potentials for a product potential</dd>
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, n_targets-1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathrm{r}_{12}\)</span>, <span class="math">\(\mathrm{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(n_targets-1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a> containing the parameters</dd>
<dt><strong>eneg</strong>: double precision  <strong>intent(out)</strong>    <em>size(n_targets)</em></dt>
<dd>the calculated electronegativity component <span class="math">\(\chi_{\alpha,ijk}\)</span></dd>
<dt>atoms: type(atom)  <em>intent(in)</em>    <em>size(n_targets)</em></dt>
<dd>a list of the actual <a class="reference internal" href="Geometry_f90.html#atom" title="atom"><tt class="xref py py-data docutils literal"><span class="pre">atom</span></tt></a> objects for which the term is calculated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_electronegativity_charge_exp">
<tt class="descname">evaluate_electronegativity_charge_exp</tt><big>(</big><em>interaction</em>, <em>eneg</em>, <em>atoms</em><big>)</big><a class="headerlink" href="#evaluate_electronegativity_charge_exp" title="Permalink to this definition">¶</a></dt>
<dd><p>Charge exp electronegativity</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a> containing the parameters</dd>
<dt><strong>eneg</strong>: double precision  <strong>intent(out)</strong>    <em>size(2)</em></dt>
<dd>the calculated electronegativity component <span class="math">\(\chi_{\alpha,ijk}\)</span></dd>
<dt>atoms: type(atom)  <em>intent(in)</em>    <em>size(2)</em></dt>
<dd>a list of the actual <a class="reference internal" href="Geometry_f90.html#atom" title="atom"><tt class="xref py py-data docutils literal"><span class="pre">atom</span></tt></a> objects for which the term is calculated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_electronegativity_charge_pair">
<tt class="descname">evaluate_electronegativity_charge_pair</tt><big>(</big><em>interaction</em>, <em>eneg</em>, <em>atoms</em><big>)</big><a class="headerlink" href="#evaluate_electronegativity_charge_pair" title="Permalink to this definition">¶</a></dt>
<dd><p>Charge pair energy electronegativity</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a> containing the parameters</dd>
<dt><strong>eneg</strong>: double precision  <strong>intent(out)</strong>    <em>size(2)</em></dt>
<dd>the calculated electronegativity component <span class="math">\(\chi_{\alpha,ijk}\)</span></dd>
<dt>atoms: type(atom)  <em>intent(in)</em>    <em>size(2)</em></dt>
<dd>a list of the actual <a class="reference internal" href="Geometry_f90.html#atom" title="atom"><tt class="xref py py-data docutils literal"><span class="pre">atom</span></tt></a> objects for which the term is calculated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_electronegativity_charge_pair_abs">
<tt class="descname">evaluate_electronegativity_charge_pair_abs</tt><big>(</big><em>interaction</em>, <em>eneg</em>, <em>atoms</em><big>)</big><a class="headerlink" href="#evaluate_electronegativity_charge_pair_abs" title="Permalink to this definition">¶</a></dt>
<dd><p>Charge pair abs energy electronegativity</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a> containing the parameters</dd>
<dt><strong>eneg</strong>: double precision  <strong>intent(out)</strong>    <em>size(2)</em></dt>
<dd>the calculated electronegativity component <span class="math">\(\chi_{\alpha,ijk}\)</span></dd>
<dt>atoms: type(atom)  <em>intent(in)</em>    <em>size(2)</em></dt>
<dd>a list of the actual <a class="reference internal" href="Geometry_f90.html#atom" title="atom"><tt class="xref py py-data docutils literal"><span class="pre">atom</span></tt></a> objects for which the term is calculated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_electronegativity_charge_self">
<tt class="descname">evaluate_electronegativity_charge_self</tt><big>(</big><em>interaction</em>, <em>eneg</em>, <em>atoms</em><big>)</big><a class="headerlink" href="#evaluate_electronegativity_charge_self" title="Permalink to this definition">¶</a></dt>
<dd><p>Charge self energy electronegativity</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a> containing the parameters</dd>
<dt><strong>eneg</strong>: double precision  <strong>intent(out)</strong>    <em>size(1)</em></dt>
<dd>the calculated electronegativity component <span class="math">\(\chi_{\alpha,ijk}\)</span></dd>
<dt>atoms: type(atom)  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>a list of the actual <a class="reference internal" href="Geometry_f90.html#atom" title="atom"><tt class="xref py py-data docutils literal"><span class="pre">atom</span></tt></a> objects for which the term is calculated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_electronegativity_component">
<tt class="descname">evaluate_electronegativity_component</tt><big>(</big><em>n_targets</em>, <em>separations</em>, <em>distances</em>, <em>interaction</em>, <em>eneg</em>, <em>atoms</em><big>)</big><a class="headerlink" href="#evaluate_electronegativity_component" title="Permalink to this definition">¶</a></dt>
<dd><p>If a potential, say, <span class="math">\(U_{ijk}\)</span> depends on the charges of atoms <span class="math">\(q_i\)</span>
it will not only create a force,
but also a difference in chemical potential <span class="math">\(\mu_i\)</span> for the atomic partial charges.
Similarly to <a class="reference internal" href="#evaluate_forces" title="evaluate_forces"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_forces()</span></tt></a>, this function evaluates the chemical
&#8216;force&#8217; on the atomic charges</p>
<div class="math">
\[\chi_{\alpha,ijk} = -\mu_{\alpha,ijk} = -\frac{\partial U_{ijk}}{\partial q_\alpha}\]</div>
<p>This routine evaluates an elemental <span class="math">\(\chi_{\alpha,ijk}\)</span>.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_targets: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of targets</dd>
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, n_targets-1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathrm{r}_{12}\)</span>, <span class="math">\(\mathrm{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(n_targets-1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a> containing the parameters</dd>
<dt><strong>eneg</strong>: double precision  <strong>intent(out)</strong>    <em>size(n_targets)</em></dt>
<dd>the calculated electronegativity component <span class="math">\(\chi_{\alpha,ijk}\)</span></dd>
<dt>atoms: type(atom)  <em>intent(in)</em>    <em>size(n_targets)</em></dt>
<dd>a list of the actual <a class="reference internal" href="Geometry_f90.html#atom" title="atom"><tt class="xref py py-data docutils literal"><span class="pre">atom</span></tt></a> objects for which the term is calculated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_energy">
<tt class="descname">evaluate_energy</tt><big>(</big><em>n_targets</em>, <em>n_product</em>, <em>separations</em>, <em>distances</em>, <em>interaction</em>, <em>energy</em>, <em>atoms</em><big>)</big><a class="headerlink" href="#evaluate_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the potential energy due to an interaction between the given
atoms. In other words, if the total potential energy is</p>
<div class="math">
\[E = \sum_{ijk} v_{ijk}\]</div>
<p>this routine evaluates <span class="math">\(v_{ijk}\)</span> for the given
atoms i, j, and k.</p>
<p>This routine can evaluate the contribution from a product potential.</p>
<p>To be consist the forces returned by <a class="reference internal" href="#evaluate_forces" title="evaluate_forces"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_forces()</span></tt></a> must be
gradients of the energies returned by <a class="reference internal" href="#evaluate_energy" title="evaluate_energy"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_energy()</span></tt></a>.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_targets: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of targets</dd>
<dt>n_product: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the number of potentials for a product potential</dd>
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, n_targets-1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathrm{r}_{12}\)</span>, <span class="math">\(\mathrm{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(n_targets-1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>energy</strong>: double precision  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the calculated energy <span class="math">\(v_{ijk}\)</span></dd>
<dt>atoms: type(atom)  <em>intent(in)</em>    <em>size(n_targets)</em></dt>
<dd>a list of the actual <a class="reference internal" href="Geometry_f90.html#atom" title="atom"><tt class="xref py py-data docutils literal"><span class="pre">atom</span></tt></a> objects for which the term is calculated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_energy_LJ">
<tt class="descname">evaluate_energy_LJ</tt><big>(</big><em>separations</em>, <em>distances</em>, <em>interaction</em>, <em>energy</em><big>)</big><a class="headerlink" href="#evaluate_energy_LJ" title="Permalink to this definition">¶</a></dt>
<dd><p>LJ energy</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, 1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathrm{r}_{12}\)</span>, <span class="math">\(\mathrm{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>energy</strong>: double precision  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the calculated energy <span class="math">\(v_{ijk}\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_energy_bond_bending">
<tt class="descname">evaluate_energy_bond_bending</tt><big>(</big><em>separations</em>, <em>distances</em>, <em>interaction</em>, <em>energy</em>, <em>atoms</em><big>)</big><a class="headerlink" href="#evaluate_energy_bond_bending" title="Permalink to this definition">¶</a></dt>
<dd><p>Bond bending energy</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, 2)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathrm{r}_{12}\)</span>, <span class="math">\(\mathrm{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(2)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>energy</strong>: double precision  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the calculated energy <span class="math">\(v_{ijk}\)</span></dd>
<dt>atoms: type(atom)  <em>intent(in)</em>    <em>size(3)</em></dt>
<dd>a list of the actual <a class="reference internal" href="Geometry_f90.html#atom" title="atom"><tt class="xref py py-data docutils literal"><span class="pre">atom</span></tt></a> objects for which the term is calculated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_energy_buckingham">
<tt class="descname">evaluate_energy_buckingham</tt><big>(</big><em>separations</em>, <em>distances</em>, <em>interaction</em>, <em>energy</em><big>)</big><a class="headerlink" href="#evaluate_energy_buckingham" title="Permalink to this definition">¶</a></dt>
<dd><p>Buckingham energy</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, 1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathrm{r}_{12}\)</span>, <span class="math">\(\mathrm{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>energy</strong>: double precision  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the calculated energy <span class="math">\(v_{ijk}\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_energy_charge_exp">
<tt class="descname">evaluate_energy_charge_exp</tt><big>(</big><em>interaction</em>, <em>energy</em>, <em>atoms</em><big>)</big><a class="headerlink" href="#evaluate_energy_charge_exp" title="Permalink to this definition">¶</a></dt>
<dd><p>Charge exp energy</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>energy</strong>: double precision  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the calculated energy <span class="math">\(v_{ijk}\)</span></dd>
<dt>atoms: type(atom)  <em>intent(in)</em>    <em>size(2)</em></dt>
<dd>a list of the actual <a class="reference internal" href="Geometry_f90.html#atom" title="atom"><tt class="xref py py-data docutils literal"><span class="pre">atom</span></tt></a> objects for which the term is calculated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_energy_charge_pair">
<tt class="descname">evaluate_energy_charge_pair</tt><big>(</big><em>interaction</em>, <em>energy</em>, <em>atoms</em><big>)</big><a class="headerlink" href="#evaluate_energy_charge_pair" title="Permalink to this definition">¶</a></dt>
<dd><p>Charge pair energy</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>energy</strong>: double precision  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the calculated energy <span class="math">\(v_{ijk}\)</span></dd>
<dt>atoms: type(atom)  <em>intent(in)</em>    <em>size(2)</em></dt>
<dd>a list of the actual <a class="reference internal" href="Geometry_f90.html#atom" title="atom"><tt class="xref py py-data docutils literal"><span class="pre">atom</span></tt></a> objects for which the term is calculated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_energy_charge_pair_abs">
<tt class="descname">evaluate_energy_charge_pair_abs</tt><big>(</big><em>interaction</em>, <em>energy</em>, <em>atoms</em><big>)</big><a class="headerlink" href="#evaluate_energy_charge_pair_abs" title="Permalink to this definition">¶</a></dt>
<dd><p>Charge pair abs energy</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>energy</strong>: double precision  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the calculated energy <span class="math">\(v_{ijk}\)</span></dd>
<dt>atoms: type(atom)  <em>intent(in)</em>    <em>size(2)</em></dt>
<dd>a list of the actual <a class="reference internal" href="Geometry_f90.html#atom" title="atom"><tt class="xref py py-data docutils literal"><span class="pre">atom</span></tt></a> objects for which the term is calculated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_energy_charge_self">
<tt class="descname">evaluate_energy_charge_self</tt><big>(</big><em>interaction</em>, <em>energy</em>, <em>atoms</em><big>)</big><a class="headerlink" href="#evaluate_energy_charge_self" title="Permalink to this definition">¶</a></dt>
<dd><p>Charge self energy</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>energy</strong>: double precision  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the calculated energy <span class="math">\(v_{ijk}\)</span></dd>
<dt>atoms: type(atom)  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>a list of the actual <a class="reference internal" href="Geometry_f90.html#atom" title="atom"><tt class="xref py py-data docutils literal"><span class="pre">atom</span></tt></a> objects for which the term is calculated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_energy_component">
<tt class="descname">evaluate_energy_component</tt><big>(</big><em>n_targets</em>, <em>separations</em>, <em>distances</em>, <em>interaction</em>, <em>energy</em>, <em>atoms</em><big>)</big><a class="headerlink" href="#evaluate_energy_component" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the potential energy due to an interaction between the given
atoms. In other words, if the total potential energy is</p>
<div class="math">
\[E = \sum_{ijk} v_{ijk}\]</div>
<p>this routine evaluates <span class="math">\(v_{ijk}\)</span> for the given
atoms i, j, and k.</p>
<p>This routine evaluates an elemental <span class="math">\(v_{\alpha,ijk}\)</span>.</p>
<p>To be consist the forces returned by <a class="reference internal" href="#evaluate_forces" title="evaluate_forces"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_forces()</span></tt></a> must be
gradients of the energies returned by <a class="reference internal" href="#evaluate_energy" title="evaluate_energy"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_energy()</span></tt></a>.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_targets: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of targets</dd>
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, n_targets-1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathrm{r}_{12}\)</span>, <span class="math">\(\mathrm{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(n_targets-1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>energy</strong>: double precision  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the calculated energy <span class="math">\(v_{ijk}\)</span></dd>
<dt>atoms: type(atom)  <em>intent(in)</em>    <em>size(n_targets)</em></dt>
<dd>a list of the actual <a class="reference internal" href="Geometry_f90.html#atom" title="atom"><tt class="xref py py-data docutils literal"><span class="pre">atom</span></tt></a> objects for which the term is calculated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_energy_constant_force">
<tt class="descname">evaluate_energy_constant_force</tt><big>(</big><em>interaction</em>, <em>energy</em>, <em>atoms</em><big>)</big><a class="headerlink" href="#evaluate_energy_constant_force" title="Permalink to this definition">¶</a></dt>
<dd><p>constant force energy</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>energy</strong>: double precision  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the calculated energy <span class="math">\(v_{ijk}\)</span></dd>
<dt>atoms: type(atom)  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>a list of the actual <a class="reference internal" href="Geometry_f90.html#atom" title="atom"><tt class="xref py py-data docutils literal"><span class="pre">atom</span></tt></a> objects for which the term is calculated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_energy_constant_potential">
<tt class="descname">evaluate_energy_constant_potential</tt><big>(</big><em>interaction</em>, <em>energy</em><big>)</big><a class="headerlink" href="#evaluate_energy_constant_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Constant potential energy</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>energy</strong>: double precision  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the calculated energy <span class="math">\(v_{ijk}\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_energy_dihedral">
<tt class="descname">evaluate_energy_dihedral</tt><big>(</big><em>separations</em>, <em>distances</em>, <em>interaction</em>, <em>energy</em>, <em>atoms</em><big>)</big><a class="headerlink" href="#evaluate_energy_dihedral" title="Permalink to this definition">¶</a></dt>
<dd><p>Dihedral angle energy</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, 3)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathrm{r}_{12}\)</span>, <span class="math">\(\mathrm{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(3)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>energy</strong>: double precision  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the calculated energy <span class="math">\(v_{ijk}\)</span></dd>
<dt>atoms: type(atom)  <em>intent(in)</em>    <em>size(4)</em></dt>
<dd>a list of the actual <a class="reference internal" href="Geometry_f90.html#atom" title="atom"><tt class="xref py py-data docutils literal"><span class="pre">atom</span></tt></a> objects for which the term is calculated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_energy_exp">
<tt class="descname">evaluate_energy_exp</tt><big>(</big><em>separations</em>, <em>distances</em>, <em>interaction</em>, <em>energy</em><big>)</big><a class="headerlink" href="#evaluate_energy_exp" title="Permalink to this definition">¶</a></dt>
<dd><p>Exp energy</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, 1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathrm{r}_{12}\)</span>, <span class="math">\(\mathrm{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>energy</strong>: double precision  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the calculated energy <span class="math">\(v_{ijk}\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_energy_power">
<tt class="descname">evaluate_energy_power</tt><big>(</big><em>separations</em>, <em>distances</em>, <em>interaction</em>, <em>energy</em><big>)</big><a class="headerlink" href="#evaluate_energy_power" title="Permalink to this definition">¶</a></dt>
<dd><p>Power energy</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, 1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathrm{r}_{12}\)</span>, <span class="math">\(\mathrm{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>energy</strong>: double precision  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the calculated energy <span class="math">\(v_{ijk}\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_energy_shift">
<tt class="descname">evaluate_energy_shift</tt><big>(</big><em>separations</em>, <em>distances</em>, <em>interaction</em>, <em>energy</em><big>)</big><a class="headerlink" href="#evaluate_energy_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift energy</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, 1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathrm{r}_{12}\)</span>, <span class="math">\(\mathrm{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>energy</strong>: double precision  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the calculated energy <span class="math">\(v_{ijk}\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_energy_spring">
<tt class="descname">evaluate_energy_spring</tt><big>(</big><em>separations</em>, <em>distances</em>, <em>interaction</em>, <em>energy</em><big>)</big><a class="headerlink" href="#evaluate_energy_spring" title="Permalink to this definition">¶</a></dt>
<dd><p>spring energy</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, 1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathrm{r}_{12}\)</span>, <span class="math">\(\mathrm{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>energy</strong>: double precision  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the calculated energy <span class="math">\(v_{ijk}\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_energy_step">
<tt class="descname">evaluate_energy_step</tt><big>(</big><em>separations</em>, <em>distances</em>, <em>interaction</em>, <em>energy</em><big>)</big><a class="headerlink" href="#evaluate_energy_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift energy</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, 1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathrm{r}_{12}\)</span>, <span class="math">\(\mathrm{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>energy</strong>: double precision  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the calculated energy <span class="math">\(v_{ijk}\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_energy_table">
<tt class="descname">evaluate_energy_table</tt><big>(</big><em>separations</em>, <em>distances</em>, <em>interaction</em>, <em>energy</em><big>)</big><a class="headerlink" href="#evaluate_energy_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Tabulated energy</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, 1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathrm{r}_{12}\)</span>, <span class="math">\(\mathrm{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>energy</strong>: double precision  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the calculated energy <span class="math">\(v_{ijk}\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_force_LJ">
<tt class="descname">evaluate_force_LJ</tt><big>(</big><em>separations</em>, <em>distances</em>, <em>interaction</em>, <em>force</em><big>)</big><a class="headerlink" href="#evaluate_force_LJ" title="Permalink to this definition">¶</a></dt>
<dd><p>LJ force</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, 1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathrm{r}_{12}\)</span>, <span class="math">\(\mathrm{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a> containing the parameters</dd>
<dt><strong>force</strong>: double precision  <strong>intent(out)</strong>    <em>size(3, 2)</em></dt>
<dd>the calculated force component <span class="math">\(\mathbf{f}_{\alpha,ijk}\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_force_bond_bending">
<tt class="descname">evaluate_force_bond_bending</tt><big>(</big><em>separations</em>, <em>distances</em>, <em>interaction</em>, <em>force</em>, <em>atoms</em><big>)</big><a class="headerlink" href="#evaluate_force_bond_bending" title="Permalink to this definition">¶</a></dt>
<dd><p>Bond bending force</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, 2)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathrm{r}_{12}\)</span>, <span class="math">\(\mathrm{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(2)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a> containing the parameters</dd>
<dt><strong>force</strong>: double precision  <strong>intent(out)</strong>    <em>size(3, 3)</em></dt>
<dd>the calculated force component <span class="math">\(\mathbf{f}_{\alpha,ijk}\)</span></dd>
<dt>atoms: type(atom)  <em>intent(in)</em>    <em>size(3)</em></dt>
<dd>a list of the actual <a class="reference internal" href="Geometry_f90.html#atom" title="atom"><tt class="xref py py-data docutils literal"><span class="pre">atom</span></tt></a> objects for which the term is calculated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_force_buckingham">
<tt class="descname">evaluate_force_buckingham</tt><big>(</big><em>separations</em>, <em>distances</em>, <em>interaction</em>, <em>force</em><big>)</big><a class="headerlink" href="#evaluate_force_buckingham" title="Permalink to this definition">¶</a></dt>
<dd><p>Buckingham force</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, 1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathrm{r}_{12}\)</span>, <span class="math">\(\mathrm{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a> containing the parameters</dd>
<dt><strong>force</strong>: double precision  <strong>intent(out)</strong>    <em>size(3, 2)</em></dt>
<dd>the calculated force component <span class="math">\(\mathbf{f}_{\alpha,ijk}\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_force_component">
<tt class="descname">evaluate_force_component</tt><big>(</big><em>n_targets</em>, <em>separations</em>, <em>distances</em>, <em>interaction</em>, <em>force</em>, <em>atoms</em><big>)</big><a class="headerlink" href="#evaluate_force_component" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the forces due to an interaction between the given
atoms. In other words, if the total force on atom <span class="math">\(\alpha\)</span> is</p>
<div class="math">
\[\mathbf{F}_\alpha = \sum_{ijk} -\nabla_\alpha v_{ijk} = \sum \mathbf{f}_{\alpha,ijk},\]</div>
<p>this routine evaluates <span class="math">\(\mathbf{f}_{\alpha,ijk}\)</span> for <span class="math">\(\alpha = (i,j,k)\)</span> for the given
atoms i, j, and k.</p>
<p>This routine evaluates an elemental <span class="math">\(\mathbf{f}_{\alpha,ijk}\)</span>.</p>
<p>To be consist the forces returned by <a class="reference internal" href="#evaluate_forces" title="evaluate_forces"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_forces()</span></tt></a> must be
gradients of the energies returned by <a class="reference internal" href="#evaluate_energy" title="evaluate_energy"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_energy()</span></tt></a>.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_targets: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of targets</dd>
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, n_targets-1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathrm{r}_{12}\)</span>, <span class="math">\(\mathrm{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(n_targets-1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a> containing the parameters</dd>
<dt><strong>force</strong>: double precision  <strong>intent(out)</strong>    <em>size(3, n_targets)</em></dt>
<dd>the calculated force component <span class="math">\(\mathbf{f}_{\alpha,ijk}\)</span></dd>
<dt>atoms: type(atom)  <em>intent(in)</em>    <em>size(n_targets)</em></dt>
<dd>a list of the actual <a class="reference internal" href="Geometry_f90.html#atom" title="atom"><tt class="xref py py-data docutils literal"><span class="pre">atom</span></tt></a> objects for which the term is calculated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_force_constant_force">
<tt class="descname">evaluate_force_constant_force</tt><big>(</big><em>interaction</em>, <em>force</em><big>)</big><a class="headerlink" href="#evaluate_force_constant_force" title="Permalink to this definition">¶</a></dt>
<dd><p>constant force</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a> containing the parameters</dd>
<dt><strong>force</strong>: double precision  <strong>intent(out)</strong>    <em>size(3, 1)</em></dt>
<dd>the calculated force component <span class="math">\(\mathbf{f}_{\alpha,ijk}\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_force_constant_potential">
<tt class="descname">evaluate_force_constant_potential</tt><big>(</big><em>interaction</em>, <em>force</em><big>)</big><a class="headerlink" href="#evaluate_force_constant_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>constant force</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a> containing the parameters</dd>
<dt><strong>force</strong>: double precision  <strong>intent(out)</strong>    <em>size(3, 1)</em></dt>
<dd>the calculated force component <span class="math">\(\mathbf{f}_{\alpha,ijk}\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_force_dihedral">
<tt class="descname">evaluate_force_dihedral</tt><big>(</big><em>separations</em>, <em>distances</em>, <em>interaction</em>, <em>force</em>, <em>atoms</em><big>)</big><a class="headerlink" href="#evaluate_force_dihedral" title="Permalink to this definition">¶</a></dt>
<dd><p>Dihedral angle force</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, 3)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathrm{r}_{12}\)</span>, <span class="math">\(\mathrm{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(3)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a> containing the parameters</dd>
<dt><strong>force</strong>: double precision  <strong>intent(out)</strong>    <em>size(3, 4)</em></dt>
<dd>the calculated force component <span class="math">\(\mathbf{f}_{\alpha,ijk}\)</span></dd>
<dt>atoms: type(atom)  <em>intent(in)</em>    <em>size(4)</em></dt>
<dd>a list of the actual <a class="reference internal" href="Geometry_f90.html#atom" title="atom"><tt class="xref py py-data docutils literal"><span class="pre">atom</span></tt></a> objects for which the term is calculated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_force_exp">
<tt class="descname">evaluate_force_exp</tt><big>(</big><em>separations</em>, <em>distances</em>, <em>interaction</em>, <em>force</em><big>)</big><a class="headerlink" href="#evaluate_force_exp" title="Permalink to this definition">¶</a></dt>
<dd><p>Exp force</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, 1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathrm{r}_{12}\)</span>, <span class="math">\(\mathrm{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a> containing the parameters</dd>
<dt><strong>force</strong>: double precision  <strong>intent(out)</strong>    <em>size(3, 2)</em></dt>
<dd>the calculated force component <span class="math">\(\mathbf{f}_{\alpha,ijk}\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_force_power">
<tt class="descname">evaluate_force_power</tt><big>(</big><em>separations</em>, <em>distances</em>, <em>interaction</em>, <em>force</em><big>)</big><a class="headerlink" href="#evaluate_force_power" title="Permalink to this definition">¶</a></dt>
<dd><p>Power force</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, 1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathrm{r}_{12}\)</span>, <span class="math">\(\mathrm{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a> containing the parameters</dd>
<dt><strong>force</strong>: double precision  <strong>intent(out)</strong>    <em>size(3, 2)</em></dt>
<dd>the calculated force component <span class="math">\(\mathbf{f}_{\alpha,ijk}\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_force_shift">
<tt class="descname">evaluate_force_shift</tt><big>(</big><em>separations</em>, <em>distances</em>, <em>interaction</em>, <em>force</em><big>)</big><a class="headerlink" href="#evaluate_force_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift force</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, 1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathrm{r}_{12}\)</span>, <span class="math">\(\mathrm{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a> containing the parameters</dd>
<dt><strong>force</strong>: double precision  <strong>intent(out)</strong>    <em>size(3, 2)</em></dt>
<dd>the calculated force component <span class="math">\(\mathbf{f}_{\alpha,ijk}\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_force_spring">
<tt class="descname">evaluate_force_spring</tt><big>(</big><em>separations</em>, <em>distances</em>, <em>interaction</em>, <em>force</em><big>)</big><a class="headerlink" href="#evaluate_force_spring" title="Permalink to this definition">¶</a></dt>
<dd><p>spring force</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, 1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathrm{r}_{12}\)</span>, <span class="math">\(\mathrm{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a> containing the parameters</dd>
<dt><strong>force</strong>: double precision  <strong>intent(out)</strong>    <em>size(3, 2)</em></dt>
<dd>the calculated force component <span class="math">\(\mathbf{f}_{\alpha,ijk}\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_force_step">
<tt class="descname">evaluate_force_step</tt><big>(</big><em>separations</em>, <em>distances</em>, <em>interaction</em>, <em>force</em><big>)</big><a class="headerlink" href="#evaluate_force_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Step force</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, 1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathrm{r}_{12}\)</span>, <span class="math">\(\mathrm{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a> containing the parameters</dd>
<dt><strong>force</strong>: double precision  <strong>intent(out)</strong>    <em>size(3, 2)</em></dt>
<dd>the calculated force component <span class="math">\(\mathbf{f}_{\alpha,ijk}\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_force_table">
<tt class="descname">evaluate_force_table</tt><big>(</big><em>separations</em>, <em>distances</em>, <em>interaction</em>, <em>force</em><big>)</big><a class="headerlink" href="#evaluate_force_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Tabulated force</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, 1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathrm{r}_{12}\)</span>, <span class="math">\(\mathrm{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a> containing the parameters</dd>
<dt><strong>force</strong>: double precision  <strong>intent(out)</strong>    <em>size(3, 2)</em></dt>
<dd>the calculated force component <span class="math">\(\mathbf{f}_{\alpha,ijk}\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_forces">
<tt class="descname">evaluate_forces</tt><big>(</big><em>n_targets</em>, <em>n_product</em>, <em>separations</em>, <em>distances</em>, <em>interaction</em>, <em>force</em>, <em>atoms</em><big>)</big><a class="headerlink" href="#evaluate_forces" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the forces due to an interaction between the given
atoms. In other words, if the total force on atom <span class="math">\(\alpha\)</span> is</p>
<div class="math">
\[\mathbf{F}_\alpha = \sum_{ijk} -\nabla_\alpha v_{ijk} = \sum \mathbf{f}_{\alpha,ijk},\]</div>
<p>this routine evaluates <span class="math">\(\mathbf{f}_{\alpha,ijk}\)</span> for <span class="math">\(\alpha = (i,j,k)\)</span> for the given
atoms i, j, and k.</p>
<p>This routine can evaluate the contribution from a product potential.</p>
<p>To be consist the forces returned by <a class="reference internal" href="#evaluate_forces" title="evaluate_forces"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_forces()</span></tt></a> must be
gradients of the energies returned by <a class="reference internal" href="#evaluate_energy" title="evaluate_energy"><tt class="xref py py-func docutils literal"><span class="pre">evaluate_energy()</span></tt></a>.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_targets: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of targets</dd>
<dt>n_product: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the number of potentials for a product potential</dd>
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, n_targets-1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathrm{r}_{12}\)</span>, <span class="math">\(\mathrm{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(n_targets-1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a> containing the parameters</dd>
<dt><strong>force</strong>: double precision  <strong>intent(out)</strong>    <em>size(3, n_targets)</em></dt>
<dd>the calculated force component <span class="math">\(\mathbf{f}_{\alpha,ijk}\)</span></dd>
<dt>atoms: type(atom)  <em>intent(in)</em>    <em>size(n_targets)</em></dt>
<dd>a list of the actual <a class="reference internal" href="Geometry_f90.html#atom" title="atom"><tt class="xref py py-data docutils literal"><span class="pre">atom</span></tt></a> objects for which the term is calculated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_pair_bond_order_factor">
<tt class="descname">evaluate_pair_bond_order_factor</tt><big>(</big><em>n_targets</em>, <em>separations</em>, <em>distances</em>, <em>bond_params</em>, <em>factor</em>, <em>atoms</em><big>)</big><a class="headerlink" href="#evaluate_pair_bond_order_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a bond order factor term.</p>
<p>By a bond order factor term, we mean the contribution from
specific atoms, <span class="math">\(c_{ijk}\)</span>, appearing in the factor</p>
<div class="math">
\[b_ij = f(\sum_{k} c_{ijk})\]</div>
<p>This routine evaluates the term <span class="math">\(c_{ijk}\)</span> for the given
atoms <span class="math">\(ijk\)</span> according to the given parameters.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_targets: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of targets</dd>
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, n_targets-1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathbf{r}_{12}\)</span>, <span class="math">\(\mathbf{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(n_targets-1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>bond_params: type(bond_order_parameters)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>factor</strong>: double precision  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the calculated bond order term <span class="math">\(c\)</span></dd>
<dt>atoms: type(atom)  <em>intent(in)</em>    <em>size(n_targets)</em></dt>
<dd>a list of the actual <a class="reference internal" href="Geometry_f90.html#atom" title="atom"><tt class="xref py py-data docutils literal"><span class="pre">atom</span></tt></a> objects for which the term is calculated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_pair_bond_order_factor_tersoff">
<tt class="descname">evaluate_pair_bond_order_factor_tersoff</tt><big>(</big><em>separations</em>, <em>distances</em>, <em>bond_params</em>, <em>factor</em>, <em>atoms</em><big>)</big><a class="headerlink" href="#evaluate_pair_bond_order_factor_tersoff" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameters:</p>
<dl class="docutils">
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, 2)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathbf{r}_{12}\)</span>, <span class="math">\(\mathbf{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(2)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>bond_params: type(bond_order_parameters)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>factor</strong>: double precision  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the calculated bond order term <span class="math">\(c\)</span></dd>
<dt>atoms: type(atom)  <em>intent(in)</em>    <em>size(3)</em></dt>
<dd>a list of the actual <a class="reference internal" href="Geometry_f90.html#atom" title="atom"><tt class="xref py py-data docutils literal"><span class="pre">atom</span></tt></a> objects for which the term is calculated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_pair_bond_order_gradient">
<tt class="descname">evaluate_pair_bond_order_gradient</tt><big>(</big><em>n_targets</em>, <em>separations</em>, <em>distances</em>, <em>bond_params</em>, <em>gradient</em>, <em>atoms</em><big>)</big><a class="headerlink" href="#evaluate_pair_bond_order_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the gradients of bond order terms with respect to moving an atom.</p>
<p>By a bond order factor term, we mean the contribution from
specific atoms, c_ijk, appearing in the factor</p>
<div class="math">
\[b_ij = f(\sum_{k} c_{ijk})\]</div>
<p>This routine evaluates the gradient term
<span class="math">\(\nabla_\alpha c_{ijk}\)</span> for the given atoms <span class="math">\(ijk\)</span> according to the given parameters.</p>
<p>The returned array has two dimensions:
gradient( coordinates, atom with respect to which we differentiate ).</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_targets: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of targets</dd>
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, n_targets-1)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathrm{r}_{12}\)</span>, <span class="math">\(\mathrm{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(n_targets-1)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>bond_params: type(bond_order_parameters)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>gradient</strong>: double precision  <strong>intent(out)</strong>    <em>size(3, n_targets)</em></dt>
<dd>the calculated bond order term <span class="math">\(\nabla_\alpha c\)</span></dd>
<dt>atoms: type(atom)  <em>intent(in)</em>    <em>size(n_targets)</em></dt>
<dd>a list of the actual <a class="reference internal" href="Geometry_f90.html#atom" title="atom"><tt class="xref py py-data docutils literal"><span class="pre">atom</span></tt></a> objects for which the term is calculated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="evaluate_pair_bond_order_gradient_tersoff">
<tt class="descname">evaluate_pair_bond_order_gradient_tersoff</tt><big>(</big><em>separations</em>, <em>distances</em>, <em>bond_params</em>, <em>gradient</em>, <em>atoms</em><big>)</big><a class="headerlink" href="#evaluate_pair_bond_order_gradient_tersoff" title="Permalink to this definition">¶</a></dt>
<dd><p>Tersoff bond order factor gradient</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>separations: double precision  <em>intent(in)</em>    <em>size(3, 2)</em></dt>
<dd>atom-atom separation vectors <span class="math">\(\mathbf{r}_{12}\)</span>, <span class="math">\(\mathbf{r}_{23}\)</span> etc. for the atoms 123...</dd>
<dt>distances: double precision  <em>intent(in)</em>    <em>size(2)</em></dt>
<dd>atom-atom distances <span class="math">\(r_{12}\)</span>, <span class="math">\(r_{23}\)</span> etc. for the atoms 123..., i.e., the norms of the separation vectors.</dd>
<dt>bond_params: type(bond_order_parameters)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> containing the parameters</dd>
<dt><strong>gradient</strong>: double precision  <strong>intent(out)</strong>    <em>size(3, 3)</em></dt>
<dd>the calculated bond order term <span class="math">\(c\)</span></dd>
<dt>atoms: type(atom)  <em>intent(in)</em>    <em>size(3)</em></dt>
<dd>a list of the actual <a class="reference internal" href="Geometry_f90.html#atom" title="atom"><tt class="xref py py-data docutils literal"><span class="pre">atom</span></tt></a> objects for which the term is calculated</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="get_bond_descriptor">
<tt class="descname">get_bond_descriptor</tt><big>(</big><em>bond_name</em>, <em>descriptor</em><big>)</big><a class="headerlink" href="#get_bond_descriptor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <a class="reference internal" href="#bond_order_descriptor" title="bond_order_descriptor"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_descriptor</span></tt></a> of a given name.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>bond_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the bond order factor</dd>
<dt><strong>descriptor</strong>: type(bond_order_descriptor)  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the matching <a class="reference internal" href="#bond_order_descriptor" title="bond_order_descriptor"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_descriptor</span></tt></a></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="get_description_of_bond_order_factor">
<tt class="descname">get_description_of_bond_order_factor</tt><big>(</big><em>bond_name</em>, <em>description</em><big>)</big><a class="headerlink" href="#get_description_of_bond_order_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the description of a bond order factor.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>bond_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the bond order factor</dd>
<dt><strong>description</strong>: character(len=pot_note_length)  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>description of the bond order factor</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="get_description_of_potential">
<tt class="descname">get_description_of_potential</tt><big>(</big><em>pot_name</em>, <em>description</em><big>)</big><a class="headerlink" href="#get_description_of_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the description of a potential.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>pot_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the potential</dd>
<dt><strong>description</strong>: character(len=pot_note_length)  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>description of the potential</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="get_descriptions_of_parameters_of_bond_order_factor">
<tt class="descname">get_descriptions_of_parameters_of_bond_order_factor</tt><big>(</big><em>bond_name</em>, <em>n_targets</em>, <em>param_notes</em><big>)</big><a class="headerlink" href="#get_descriptions_of_parameters_of_bond_order_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the descriptions of the parameters of a bond order factor
as a list of strings.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>bond_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the bond order factor</dd>
<dt>n_targets: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>1 for scaling, 2 for local sum parameters</dd>
<dt>param_notes: character(len=param_note_length)  <em>intent()</em>  <em>pointer</em>  <em>size(:)</em></dt>
<dd>descriptions of the parameters</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="get_descriptions_of_parameters_of_potential">
<tt class="descname">get_descriptions_of_parameters_of_potential</tt><big>(</big><em>pot_name</em>, <em>param_notes</em><big>)</big><a class="headerlink" href="#get_descriptions_of_parameters_of_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the descriptions of the parameters of a potential
as a list of strings.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>pot_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the potential</dd>
<dt>param_notes: character(len=param_note_length)  <em>intent()</em>  <em>pointer</em>  <em>size(:)</em></dt>
<dd>descriptions of the parameters</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="get_descriptor">
<tt class="descname">get_descriptor</tt><big>(</big><em>pot_name</em>, <em>descriptor</em><big>)</big><a class="headerlink" href="#get_descriptor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <a class="reference internal" href="#potential_descriptor" title="potential_descriptor"><tt class="xref py py-data docutils literal"><span class="pre">potential_descriptor</span></tt></a> of a given name.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>pot_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the potential</dd>
<dt><strong>descriptor</strong>: type(potential_descriptor)  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the matching <a class="reference internal" href="#potential_descriptor" title="potential_descriptor"><tt class="xref py py-data docutils literal"><span class="pre">potential_descriptor</span></tt></a></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="get_index_of_bond_order_factor">
<tt class="descname">get_index_of_bond_order_factor</tt><big>(</big><em>bond_name</em>, <em>index</em><big>)</big><a class="headerlink" href="#get_index_of_bond_order_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of a <a class="reference internal" href="#bond_order_descriptor" title="bond_order_descriptor"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_descriptor</span></tt></a> in the internal list of bond order factor types <a class="reference internal" href="#bond_order_descriptors" title="bond_order_descriptors"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_descriptors</span></tt></a>.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>bond_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the bond order factor - a keyword</dd>
<dt><strong>index</strong>: integer  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>index of the potential in the internal array</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="get_index_of_parameter_of_bond_order_factor">
<tt class="descname">get_index_of_parameter_of_bond_order_factor</tt><big>(</big><em>bond_name</em>, <em>param_name</em>, <em>index</em>, <em>n_targets</em><big>)</big><a class="headerlink" href="#get_index_of_parameter_of_bond_order_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of a parameter of a bond order factor in the
internal list of parameters. Since bond order factors can have
parameters for different number of targets, also the type
(scaling vs. local sum) of this parameter is returned.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>bond_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the bond order factor</dd>
<dt>param_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the parameter</dd>
<dt><strong>index</strong>: integer  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>index of the parameter</dd>
<dt><strong>n_targets</strong>: integer  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>1 for scaling, 2 for local sum parameters</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="get_index_of_parameter_of_potential">
<tt class="descname">get_index_of_parameter_of_potential</tt><big>(</big><em>pot_name</em>, <em>param_name</em>, <em>index</em><big>)</big><a class="headerlink" href="#get_index_of_parameter_of_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of a parameter of a potential in the
internal list of parameters.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>pot_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the potential</dd>
<dt>param_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the parameter</dd>
<dt><strong>index</strong>: integer  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the index of the parameter</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="get_index_of_potential">
<tt class="descname">get_index_of_potential</tt><big>(</big><em>pot_name</em>, <em>index</em><big>)</big><a class="headerlink" href="#get_index_of_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of a <a class="reference internal" href="#potential_descriptor" title="potential_descriptor"><tt class="xref py py-data docutils literal"><span class="pre">potential_descriptor</span></tt></a> in the internal list of potential types <a class="reference internal" href="#potential_descriptors" title="potential_descriptors"><tt class="xref py py-data docutils literal"><span class="pre">potential_descriptors</span></tt></a>.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>pot_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the potential - a keyword</dd>
<dt><strong>index</strong>: integer  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>index of the potential in the internal array</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="get_level_of_bond_order_factor">
<tt class="descname">get_level_of_bond_order_factor</tt><big>(</big><em>bond_name</em>, <em>level</em><big>)</big><a class="headerlink" href="#get_level_of_bond_order_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the level of a bond order factor (i.e., is the factor per-atom or per-pair).</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>bond_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the bond order factor</dd>
<dt><strong>level</strong>: integer  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>level of the factor</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="get_level_of_bond_order_factor_index">
<tt class="descname">get_level_of_bond_order_factor_index</tt><big>(</big><em>bond_index</em>, <em>level</em><big>)</big><a class="headerlink" href="#get_level_of_bond_order_factor_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the level of a bond order factor (i.e., is the factor per-atom or per-pair).</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>bond_index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the bond order factor</dd>
<dt><strong>level</strong>: integer  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>level of the factor</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="get_names_of_parameters_of_bond_order_factor">
<tt class="descname">get_names_of_parameters_of_bond_order_factor</tt><big>(</big><em>bond_name</em>, <em>n_targets</em>, <em>param_names</em><big>)</big><a class="headerlink" href="#get_names_of_parameters_of_bond_order_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the names of parameters of a bond order factor as a list of strings.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>bond_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the bond order factor</dd>
<dt>n_targets: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>1 for scaling, 2 for local sum parameters</dd>
<dt>param_names: character(len=param_name_length)  <em>intent()</em>  <em>pointer</em>  <em>size(:)</em></dt>
<dd>names of the parameters</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="get_names_of_parameters_of_potential">
<tt class="descname">get_names_of_parameters_of_potential</tt><big>(</big><em>pot_name</em>, <em>param_names</em><big>)</big><a class="headerlink" href="#get_names_of_parameters_of_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the names of parameters of a potential as a list of strings.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>pot_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the potential</dd>
<dt>param_names: character(len=param_name_length)  <em>intent()</em>  <em>pointer</em>  <em>size(:)</em></dt>
<dd>names of the parameters</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="get_number_of_bond_order_factors">
<tt class="descname">get_number_of_bond_order_factors</tt><big>(</big><em>n_bond</em><big>)</big><a class="headerlink" href="#get_number_of_bond_order_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of <a class="reference internal" href="#bond_order_descriptor" title="bond_order_descriptor"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_descriptor</span></tt></a> known.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt><strong>n_bond</strong>: integer  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>number of bond order factor types</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="get_number_of_parameters_of_bond_order_factor">
<tt class="descname">get_number_of_parameters_of_bond_order_factor</tt><big>(</big><em>bond_name</em>, <em>n_targets</em>, <em>n_params</em><big>)</big><a class="headerlink" href="#get_number_of_parameters_of_bond_order_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of parameters of a bond order factor as an integer.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>bond_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the bond order factor</dd>
<dt>n_targets: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>1 for scaling parameters, 2 for local sum parameters</dd>
<dt><strong>n_params</strong>: integer  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>number of parameters</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="get_number_of_parameters_of_potential">
<tt class="descname">get_number_of_parameters_of_potential</tt><big>(</big><em>pot_name</em>, <em>n_params</em><big>)</big><a class="headerlink" href="#get_number_of_parameters_of_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of parameters of a potential.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>pot_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the potential</dd>
<dt><strong>n_params</strong>: integer  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>number of parameters</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="get_number_of_potentials">
<tt class="descname">get_number_of_potentials</tt><big>(</big><em>n_pots</em><big>)</big><a class="headerlink" href="#get_number_of_potentials" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of <a class="reference internal" href="#potential_descriptor" title="potential_descriptor"><tt class="xref py py-data docutils literal"><span class="pre">potential_descriptor</span></tt></a>  known.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt><strong>n_pots</strong>: integer  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>number of potential types</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="get_number_of_targets_of_bond_order_factor">
<tt class="descname">get_number_of_targets_of_bond_order_factor</tt><big>(</big><em>bond_name</em>, <em>n_target</em><big>)</big><a class="headerlink" href="#get_number_of_targets_of_bond_order_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of targets (i.e., bodies) of a bond order factor.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>bond_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the bond order factor</dd>
<dt><strong>n_target</strong>: integer  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>number of targets</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="get_number_of_targets_of_bond_order_factor_index">
<tt class="descname">get_number_of_targets_of_bond_order_factor_index</tt><big>(</big><em>bond_index</em>, <em>n_target</em><big>)</big><a class="headerlink" href="#get_number_of_targets_of_bond_order_factor_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of targets (i.e., bodies) of a bond order factor
specified by its index.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>bond_index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index of the bond order factor</dd>
<dt><strong>n_target</strong>: integer  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>number of targets</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="get_number_of_targets_of_potential">
<tt class="descname">get_number_of_targets_of_potential</tt><big>(</big><em>pot_name</em>, <em>n_target</em><big>)</big><a class="headerlink" href="#get_number_of_targets_of_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of targets (i.e., bodies) of a potential.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>pot_name: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of the potential</dd>
<dt><strong>n_target</strong>: integer  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>number of targets</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="get_number_of_targets_of_potential_index">
<tt class="descname">get_number_of_targets_of_potential_index</tt><big>(</big><em>pot_index</em>, <em>n_target</em><big>)</big><a class="headerlink" href="#get_number_of_targets_of_potential_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of targets (i.e., bodies) of a potential
specified by its index.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>pot_index: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>index of the potential</dd>
<dt><strong>n_target</strong>: integer  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>number of targets</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="initialize_bond_order_factor_characterizers">
<tt class="descname">initialize_bond_order_factor_characterizers</tt><big>(</big><big>)</big><a class="headerlink" href="#initialize_bond_order_factor_characterizers" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates bond order factor characterizers.</p>
<p>This routine is meant to be run once, as pysic is
imported, to create the characterizers for
bond order factors. Once created, they are accessible
by both the python and fortran sides of pysic
as a tool for describing the general structure
of bond order factor objects.</p>
</dd></dl>

<dl class="function">
<dt id="initialize_potential_characterizers">
<tt class="descname">initialize_potential_characterizers</tt><big>(</big><big>)</big><a class="headerlink" href="#initialize_potential_characterizers" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates potential characterizers.</p>
<p>This routine is meant to be run once, as pysic is
imported, to create the characterizers for
potentials. Once created, they are accessible
by both the python and fortran sides of pysic
as a tool for describing the general structure
of potential objects.</p>
</dd></dl>

<dl class="function">
<dt id="is_valid_bond_order_factor">
<tt class="descname">is_valid_bond_order_factor</tt><big>(</big><em>string</em>, <em>is_valid</em><big>)</big><a class="headerlink" href="#is_valid_bond_order_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the given keyword is the name of a bond order factor
and false otherwise.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>string: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of a bond order factor</dd>
<dt><strong>is_valid</strong>: logical  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>true if string is a name of a bond order factor</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="is_valid_potential">
<tt class="descname">is_valid_potential</tt><big>(</big><em>string</em>, <em>is_valid</em><big>)</big><a class="headerlink" href="#is_valid_potential" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the given keyword is the name of a potential
and false otherwise.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>string: character(len=*)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>name of a potential</dd>
<dt><strong>is_valid</strong>: logical  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>true if string is a name of a potential</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="list_bond_order_factors">
<tt class="descname">list_bond_order_factors</tt><big>(</big><em>n_bonds</em>, <em>bonds</em><big>)</big><a class="headerlink" href="#list_bond_order_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the names of <a class="reference internal" href="#bond_order_descriptor" title="bond_order_descriptor"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_descriptor</span></tt></a> objects.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_bonds: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of bond order factor types</dd>
<dt><strong>bonds</strong>: character(len=pot_name_length)  <strong>intent(out)</strong>    <em>size(n_bonds)</em></dt>
<dd>names of the bond order factor types</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="list_potentials">
<tt class="descname">list_potentials</tt><big>(</big><em>n_pots</em>, <em>pots</em><big>)</big><a class="headerlink" href="#list_potentials" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the names of <a class="reference internal" href="#potential_descriptor" title="potential_descriptor"><tt class="xref py py-data docutils literal"><span class="pre">potential_descriptor</span></tt></a> objects.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>n_pots: integer  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>number of potential types</dd>
<dt><strong>pots</strong>: character(len=pot_name_length)  <strong>intent(out)</strong>    <em>size(n_pots)</em></dt>
<dd>names of the potential types</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="post_process_bond_order_factor">
<tt class="descname">post_process_bond_order_factor</tt><big>(</big><em>raw_sum</em>, <em>bond_params</em>, <em>factor_out</em><big>)</big><a class="headerlink" href="#post_process_bond_order_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bond-order post processing, i.e.,
application of per-atom scaling functions.</p>
<p>By post processing, we mean any operations done after calculating the
sum of pair- and many-body terms. That is, if a factor is, say,</p>
<div class="math">
\[b_i = f(\sum_j c_{ij}) = 1 + \sum_j c_{ij},\]</div>
<p>the <span class="math">\(\sum_j c_ij\)</span> would have been calculated already and the
operation <span class="math">\(f(x) = 1 + x\)</span> remains to be carried out.
The post processing is done per atom regardless of if the
bond factor is of a pair or many body type.</p>
<p>This routine applies the scaling function on the given
bond order sum accoding to the given parameters.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>raw_sum: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the precalculated bond order sum, <span class="math">\(\sum_j c_ij\)</span> in the above example</dd>
<dt>bond_params: type(bond_order_parameters)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> specifying the parameters</dd>
<dt><strong>factor_out</strong>: double precision  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the calculated bond order factor <span class="math">\(b_i\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="post_process_bond_order_factor_scaler_1">
<tt class="descname">post_process_bond_order_factor_scaler_1</tt><big>(</big><em>raw_sum</em>, <em>bond_params</em>, <em>factor_out</em><big>)</big><a class="headerlink" href="#post_process_bond_order_factor_scaler_1" title="Permalink to this definition">¶</a></dt>
<dd><p>Scaler post process factor</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>raw_sum: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the precalculated bond order sum, <span class="math">\(\sum_j c_ij\)</span> in the above example</dd>
<dt>bond_params: type(bond_order_parameters)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> specifying the parameters</dd>
<dt><strong>factor_out</strong>: double precision  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the calculated bond order factor <span class="math">\(b_i\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="post_process_bond_order_factor_scaler_sqrt">
<tt class="descname">post_process_bond_order_factor_scaler_sqrt</tt><big>(</big><em>raw_sum</em>, <em>bond_params</em>, <em>factor_out</em><big>)</big><a class="headerlink" href="#post_process_bond_order_factor_scaler_sqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Square root scaler post process factor</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>raw_sum: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the precalculated bond order sum, <span class="math">\(\sum_j c_ij\)</span> in the above example</dd>
<dt>bond_params: type(bond_order_parameters)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> specifying the parameters</dd>
<dt><strong>factor_out</strong>: double precision  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the calculated bond order factor <span class="math">\(b_i\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="post_process_bond_order_factor_scaler_table">
<tt class="descname">post_process_bond_order_factor_scaler_table</tt><big>(</big><em>raw_sum</em>, <em>bond_params</em>, <em>factor_out</em><big>)</big><a class="headerlink" href="#post_process_bond_order_factor_scaler_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Tabulated scaler post process factor</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>raw_sum: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the precalculated bond order sum, <span class="math">\(\sum_j c_ij\)</span> in the above example</dd>
<dt>bond_params: type(bond_order_parameters)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> specifying the parameters</dd>
<dt><strong>factor_out</strong>: double precision  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the calculated bond order factor <span class="math">\(b_i\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="post_process_bond_order_factor_tersoff">
<tt class="descname">post_process_bond_order_factor_tersoff</tt><big>(</big><em>raw_sum</em>, <em>bond_params</em>, <em>factor_out</em><big>)</big><a class="headerlink" href="#post_process_bond_order_factor_tersoff" title="Permalink to this definition">¶</a></dt>
<dd><p>Tersoff post process factor</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>raw_sum: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the precalculated bond order sum, <span class="math">\(\sum_k c_{ijk}\)</span> in the above example</dd>
<dt>bond_params: type(bond_order_parameters)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> specifying the parameters</dd>
<dt><strong>factor_out</strong>: double precision  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the calculated bond order factor <span class="math">\(b_{ij}\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="post_process_bond_order_gradient">
<tt class="descname">post_process_bond_order_gradient</tt><big>(</big><em>raw_sum</em>, <em>raw_gradient</em>, <em>bond_params</em>, <em>factor_out</em><big>)</big><a class="headerlink" href="#post_process_bond_order_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Bond-order post processing, i.e.,
application of per-atom scaling functions.</p>
<p>By post processing, we mean any operations done after calculating the
sum of pair- and many-body terms. That is, if a factor is, say,</p>
<div class="math">
\[b_i = f(\sum_j c_{ij}) = 1 + \sum_j c_{ij},\]</div>
<p>the <span class="math">\(\sum_j c_{ij}\)</span> would have been calculated already and the
operation <span class="math">\(f(x) = 1 + x\)</span> remains to be carried out.
The post processing is done per atom regardless of if the
bond factor is of a pair or many body type.</p>
<p>For gradients, one needs to evaluate</p>
<div class="math">
\[\nabla_\alpha b_i = f'(\sum_j c_{ij}) \nabla_\alpha \sum_j c_{ij}\]</div>
<p>This routine applies the scaling function on the given
bond order sum and gradient accoding to the given parameters.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>raw_sum: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the precalculated bond order sum, <span class="math">\(\sum_j c_ij\)</span> in the above example</dd>
<dt>raw_gradient: double precision  <em>intent(in)</em>    <em>size(3)</em></dt>
<dd>the precalculated bond order gradient sum, <span class="math">\(\nabla_\alpha \sum_j c_ij\)</span> in the above example</dd>
<dt>bond_params: type(bond_order_parameters)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> specifying the parameters</dd>
<dt><strong>factor_out</strong>: double precision  <strong>intent(inout)</strong>    <em>size(3)</em></dt>
<dd>the calculated bond order factor <span class="math">\(\nabla_\alpha b_i\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="post_process_bond_order_gradient_scaler_1">
<tt class="descname">post_process_bond_order_gradient_scaler_1</tt><big>(</big><em>raw_sum</em>, <em>raw_gradient</em>, <em>bond_params</em>, <em>factor_out</em><big>)</big><a class="headerlink" href="#post_process_bond_order_gradient_scaler_1" title="Permalink to this definition">¶</a></dt>
<dd><p>Scaler post process gradient</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>raw_sum: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the precalculated bond order sum, <span class="math">\(\sum_j c_ij\)</span> in the above example</dd>
<dt>raw_gradient: double precision  <em>intent(in)</em>    <em>size(3)</em></dt>
<dd>the precalculated bond order gradient sum, <span class="math">\(\nabla_\alpha \sum_j c_ij\)</span> in the above example</dd>
<dt>bond_params: type(bond_order_parameters)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> specifying the parameters</dd>
<dt><strong>factor_out</strong>: double precision  <strong>intent(out)</strong>    <em>size(3)</em></dt>
<dd>the calculated bond order factor <span class="math">\(b_i\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="post_process_bond_order_gradient_scaler_sqrt">
<tt class="descname">post_process_bond_order_gradient_scaler_sqrt</tt><big>(</big><em>raw_sum</em>, <em>raw_gradient</em>, <em>bond_params</em>, <em>factor_out</em><big>)</big><a class="headerlink" href="#post_process_bond_order_gradient_scaler_sqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Square root scaler post process gradient</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>raw_sum: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the precalculated bond order sum, <span class="math">\(\sum_j c_ij\)</span> in the above example</dd>
<dt>raw_gradient: double precision  <em>intent(in)</em>    <em>size(3)</em></dt>
<dd>the precalculated bond order gradient sum, <span class="math">\(\nabla_\alpha \sum_j c_ij\)</span> in the above example</dd>
<dt>bond_params: type(bond_order_parameters)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> specifying the parameters</dd>
<dt><strong>factor_out</strong>: double precision  <strong>intent(out)</strong>    <em>size(3)</em></dt>
<dd>the calculated bond order factor <span class="math">\(b_i\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="post_process_bond_order_gradient_scaler_table">
<tt class="descname">post_process_bond_order_gradient_scaler_table</tt><big>(</big><em>raw_sum</em>, <em>raw_gradient</em>, <em>bond_params</em>, <em>factor_out</em><big>)</big><a class="headerlink" href="#post_process_bond_order_gradient_scaler_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Tabulated scaler post process gradient</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>raw_sum: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the precalculated bond order sum, <span class="math">\(\sum_j c_ij\)</span> in the above example</dd>
<dt>raw_gradient: double precision  <em>intent(in)</em>    <em>size(3)</em></dt>
<dd>the precalculated bond order gradient sum, <span class="math">\(\nabla_\alpha \sum_j c_ij\)</span> in the above example</dd>
<dt>bond_params: type(bond_order_parameters)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> specifying the parameters</dd>
<dt><strong>factor_out</strong>: double precision  <strong>intent(out)</strong>    <em>size(3)</em></dt>
<dd>the calculated bond order factor <span class="math">\(b_i\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="post_process_bond_order_gradient_tersoff">
<tt class="descname">post_process_bond_order_gradient_tersoff</tt><big>(</big><em>raw_sum</em>, <em>raw_gradient</em>, <em>bond_params</em>, <em>factor_out</em><big>)</big><a class="headerlink" href="#post_process_bond_order_gradient_tersoff" title="Permalink to this definition">¶</a></dt>
<dd><p>Tersoff post process gradient</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>raw_sum: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the precalculated bond order sum, <span class="math">\(\sum_j c_ij\)</span> in the above example</dd>
<dt>raw_gradient: double precision  <em>intent(in)</em>    <em>size(3)</em></dt>
<dd>the precalculated bond order gradient sum, <span class="math">\(\nabla_\alpha \sum_j c_ij\)</span> in the above example</dd>
<dt>bond_params: type(bond_order_parameters)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>a <a class="reference internal" href="#bond_order_parameters" title="bond_order_parameters"><tt class="xref py py-data docutils literal"><span class="pre">bond_order_parameters</span></tt></a> specifying the parameters</dd>
<dt><strong>factor_out</strong>: double precision  <strong>intent(out)</strong>    <em>size(3)</em></dt>
<dd>the calculated bond order factor <span class="math">\(b_i\)</span></dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="potential_affects_atom">
<tt class="descname">potential_affects_atom</tt><big>(</big><em>interaction</em>, <em>atom_in</em>, <em>affects</em>, <em>position</em><big>)</big><a class="headerlink" href="#potential_affects_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether the given potential affects the specific atom.</p>
<p>For potentials, the atoms are specified as valid targets by
the atomic symbol, index, or tag.</p>
<p>If position is not given, then the routine returns true if
the atom can appear in the potential in any role.
If position is given, then true is returned only if the atom
is valid for that particular position.</p>
<p>For instance, in a 3-body potential A-B-C, the potential
May be specified so that only certain elements are valid for
positions A and C while some other elements are valid for B.
In a water molecule, for instance, we could have an H-O-H
bond bending potential, but no H-H-O potentials.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>interaction: type(potential)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the <a class="reference internal" href="#potential" title="potential"><tt class="xref py py-data docutils literal"><span class="pre">potential</span></tt></a></dd>
<dt>atom_in: type(atom)  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the <a class="reference internal" href="Geometry_f90.html#atom" title="atom"><tt class="xref py py-data docutils literal"><span class="pre">atom</span></tt></a></dd>
<dt><strong>affects</strong>: logical  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>true if the potential affects the atom</dd>
<dt>position: integer  <em>intent(in)</em>    <em>scalar</em>  <em>optional</em></dt>
<dd>specifies the particular role of the atom in the interaction</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="smoothening_derivative">
<tt class="descname">smoothening_derivative</tt><big>(</big><em>r</em>, <em>hard_cut</em>, <em>soft_cut</em>, <em>factor</em><big>)</big><a class="headerlink" href="#smoothening_derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivative of the function for smoothening potential
and bond order cutoffs.
In principle any &#8220;nice&#8221; function which goes from 1 to 0
in a finite interval could be used. Here, we choose</p>
<div class="math">
\[f(r) = \frac{1}{2} ( 1 + \cos \pi \frac{r-r_\mathrm{soft}}{r_\mathrm{hard}-r_\mathrm{soft}} )\]</div>
<p>for <span class="math">\(r \in [r_\mathrm{soft},r_\mathrm{hard}]\)</span>.
The derivative is then</p>
<div class="math">
\[f'(r) = \frac{\pi}{2 (r_\mathrm{soft}-r_\mathrm{hard})} \sin \pi \frac{r-r_\mathrm{soft}}{r_\mathrm{hard}-r_\mathrm{soft}}.\]</div>
<p>This routine takes as arguments <span class="math">\(r\)</span>, <span class="math">\(r_\mathrm{soft}\)</span>, and <span class="math">\(r_\mathrm{hard}\)</span>, and
returns the value of the derivative of the smoothening function.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>r: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>distance <span class="math">\(r\)</span></dd>
<dt>hard_cut: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the hard cutoff <span class="math">\(r_\mathrm{hard}\)</span></dd>
<dt>soft_cut: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the soft cutoff <span class="math">\(r_\mathrm{soft}\)</span></dd>
<dt><strong>factor</strong>: double precision  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the calculated derivative of the smoothening factor</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="smoothening_factor">
<tt class="descname">smoothening_factor</tt><big>(</big><em>r</em>, <em>hard_cut</em>, <em>soft_cut</em>, <em>factor</em><big>)</big><a class="headerlink" href="#smoothening_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Function for smoothening potential and bond order cutoffs.
In principle any &#8220;nice&#8221; function which goes from 1 to 0
in a finite interval could be used. Here, we choose</p>
<div class="math">
\[f(r) = \frac{1}{2} ( 1 + \cos \pi \frac{r-r_\mathrm{soft}}{r_\mathrm{hard}-r_\mathrm{soft}} )\]</div>
<p>for <span class="math">\(r \in [r_\mathrm{soft},r_\mathrm{hard}]\)</span>.</p>
<p>This routine takes as arguments <span class="math">\(r\)</span>, <span class="math">\(r_\mathrm{soft}\)</span>, and <span class="math">\(r_\mathrm{hard}\)</span>, and
returns the value of the smoothening function.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>r: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>distance <span class="math">\(r\)</span></dd>
<dt>hard_cut: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the hard cutoff <span class="math">\(r_\mathrm{hard}\)</span></dd>
<dt>soft_cut: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the soft cutoff <span class="math">\(r_\mathrm{soft}\)</span></dd>
<dt><strong>factor</strong>: double precision  <strong>intent(out)</strong>    <em>scalar</em></dt>
<dd>the calculated smoothening factor</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="smoothening_gradient">
<tt class="descname">smoothening_gradient</tt><big>(</big><em>unit_vector</em>, <em>r</em>, <em>hard_cut</em>, <em>soft_cut</em>, <em>gradient</em><big>)</big><a class="headerlink" href="#smoothening_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Gradient of the function for smoothening potential
and bond order cutoffs.
In principle any &#8220;nice&#8221; function which goes from 1 to 0
in a finite interval could be used. Here, we choose</p>
<div class="math">
\[f(r) = \frac{1}{2} ( 1 + \cos \pi \frac{r-r_\mathrm{soft}}{r_\mathrm{hard}-r_\mathrm{soft}} )\]</div>
<p>for <span class="math">\(r \in [r_\mathrm{soft},r_\mathrm{hard}]\)</span>.
The derivative is then</p>
<div class="math">
\[f'(r) = \frac{\pi}{2 (r_\mathrm{soft}-r_\mathrm{hard})} \sin \pi \frac{r-r_\mathrm{soft}}{r_\mathrm{hard}-r_\mathrm{soft}}.\]</div>
<p>and the gradient with respect to <span class="math">\(r\)</span></p>
<div class="math">
\[\nabla f(r) = f'(r) \nabla r = f'(r) \hat{r}\]</div>
<p>where <span class="math">\(\hat{r}\)</span> is the unit vector in the direction of <span class="math">\(\mathbf{r}\)</span>.</p>
<p>This routine takes as arguments <span class="math">\(\hat{r}\)</span>, <span class="math">\(r\)</span>, <span class="math">\(r_\mathrm{soft}\)</span>, and <span class="math">\(r_\mathrm{hard}\)</span>, and
returns the value of the gradient of the smoothening function.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>unit_vector: double precision  <em>intent(in)</em>    <em>size(3)</em></dt>
<dd>the vector <span class="math">\(\hat{r}\)</span></dd>
<dt>r: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>distance <span class="math">\(r\)</span></dd>
<dt>hard_cut: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the hard cutoff <span class="math">\(r_\mathrm{hard}\)</span></dd>
<dt>soft_cut: double precision  <em>intent(in)</em>    <em>scalar</em></dt>
<dd>the soft cutoff <span class="math">\(r_\mathrm{soft}\)</span></dd>
<dt><strong>gradient</strong>: double precision  <strong>intent(out)</strong>    <em>size(3)</em></dt>
<dd>the calculated derivative of the smoothening factor</dd>
</dl>
</dd></dl>

</div></blockquote>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="Geometry_f90.html" title="geometry (Geometry.f90)"
             >next</a> |</li>
        <li class="right" >
          <a href="Core_f90.html" title="pysic_core (Core.f90)"
             >previous</a> |</li>
        <li><a href="index.html">Pysic 0.6 documentation</a> &raquo;</li>
          <li><a href="pysic_fortran.html" >Pysic Fortran module</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011-2013, Teemu Hynninen.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>